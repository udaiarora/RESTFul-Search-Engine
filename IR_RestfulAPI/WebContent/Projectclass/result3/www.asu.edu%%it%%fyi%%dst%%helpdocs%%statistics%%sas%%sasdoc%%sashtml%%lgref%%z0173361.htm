<HTML>
<!-- This page produced Mon Jul 19 13:58:41 EDT 1999
 -->
<!-- Used program version 1.118.1.2 from beta -->
<HEAD>
<!-- <META http-equiv="Content-Type" content="text/html; charset="> -->
<TITLE>Statements : MODIFY </TITLE></HEAD>
<BODY bgcolor="#FFFFFF">
<!-- navigation -->
<TABLE cellpadding="0" cellspacing="0">
<TR valign="top">
<TD align="center">
<A href="z0293668.htm">
<IMG border="0" SRC="../common/images/cont1.gif"><BR><FONT size="-2">Chapter Contents</FONT></A></TD>
<TD align="center">
<A href="z0227561.htm">
<IMG border="0" src="../common/images/prev1.gif"><BR><FONT size="-2">Previous</FONT></A></TD>
<TD align="center">
<A href="z0289429.htm">
<IMG border="0" SRC="../common/images/next1.gif"><BR><FONT size="-2">Next</FONT></A></TD>
</TR></TABLE>
<!-- running head -->
<TABLE width="100%" cellpadding="4">
<TR valign="MIDDLE">
<TD bgcolor="#CCCC99"><I><FONT size="2">MODIFY</FONT></I></TD>
</TR>
</TABLE><H1><FONT size="5"><A name="z0173361">MODIFY</A></FONT></H1>

<P><HR><BR><B>Replaces, deletes, and appends observations in an existing SAS
data set in place; does not create an additional copy   </B><p>

<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="right" bgcolor="#F5F5F5" nowrap><B>Valid:</B></TD>
<TD bgcolor="#CCCCCC" align="left">in a DATA step
</TD></TR>
<TR valign="top">
<TD align="right" bgcolor="#F5F5F5" nowrap><B>Category:</B></TD>
<TD bgcolor="#CCCCCC" align="left">File-handling
</TD></TR>
<TR valign="top">
<TD align="right" bgcolor="#F5F5F5" nowrap><B>Type:</B></TD>
<TD bgcolor="#CCCCCC" align="left">Executable
</TD></TR>
<TR valign="top">
<TD align="right" bgcolor="#F5F5F5" nowrap><B>Restriction:</B></TD>
<TD bgcolor="#CCCCCC" align="left">Cannot modify the descriptor portion of
a SAS data set, such as adding a variable
</TD></TR>
</TABLE><HR>
<TABLE cellspacing="0" cellpadding="1">
<TR>
<TD colspan="2"><A href="z0173361.htm#zid-2480"><FONT size="2"><B>Syntax</b></FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0173361.htm#zid-2481"><FONT size="2"><B>Arguments</b></FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0173361.htm#z0163053"><FONT size="2"><B>Details</b></FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0173361.htm#z0173362"><FONT size="2"><IMG border="0" src=" ../common/images/sym01.gif" alt="[1]">Matching Access</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0173361.htm#z0173363"><FONT size="2"><IMG border="0" src=" ../common/images/sym01.gif" alt="[1]">Duplicate BY Values</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0173361.htm#z0173364"><FONT size="2"><IMG border="0" src=" ../common/images/sym02.gif" alt="[2]">Direct Access by Indexed Values</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0173361.htm#z0173365"><FONT size="2"><IMG border="0" src=" ../common/images/sym02.gif" alt="[2]">Duplicate Index Values</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0173361.htm#z0173366"><FONT size="2"><IMG border="0" src=" ../common/images/sym03.gif" alt="[3]">Direct (Random) Access by Observation Number</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0173361.htm#z0343410"><FONT size="2"><IMG border="0" src=" ../common/images/sym04.gif" alt="[4]">Sequential Access</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0173361.htm#z0173367"><FONT size="2">Automatic Variable _IORC_ and the SYSRC Autocall Macro</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0173361.htm#z0173368"><FONT size="2">Writing Observations When MODIFY Is Used in a DATA Step</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0173361.htm#z0173369"><FONT size="2">Using MODIFY in a SAS/SHARE Environment</FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0173361.htm#z0163362"><FONT size="2"><B>Comparisons</b></FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0173361.htm#z0172442"><FONT size="2"><B>Input Data Set for Examples</b></FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0173361.htm#z0173370"><FONT size="2"><B>Examples</b></FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0173361.htm#z0173371"><FONT size="2">Example 1: Modifying All Observations</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0173361.htm#z0173372"><FONT size="2">Example 2: Modifying Observations Using a Transaction Data Set</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0173361.htm#z0173373"><FONT size="2">Example 3: Modifying Observations Located by Observation Number</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0173361.htm#z0173374"><FONT size="2">Example 4: Modifying Observations Located by an Index</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0173361.htm#z0173375"><FONT size="2">Example 5: Handling Duplicate Index Values</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0173361.htm#z0173376"><FONT size="2">Example 6: Controlling I/O</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0173361.htm#z0173377"><FONT size="2">Example 7: Replacing and Removing Observations and Writing Observations to Different SAS Data Sets</FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0173361.htm#z0173378"><FONT size="2"><B>See Also</b></FONT></A></TD></TR></TABLE>
<TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><H2><A name="zid-2480">Syntax</A></H2></TD></TR></TABLE>

<TABLE cellpadding="4" cellspacing="2">
<TR valign="top"><TD>
<IMG border="0" src=" ../common/images/sym01.gif" alt="[1]"><B>MODIFY</B> <I>master-data-set</I>
&lt;(<I>data-set-option(s)</I>)&gt; <I>transaction-data-set</I> &lt;(<I>data-set-option(s)</I>)&gt;
<BR>
&lt;NOBS=<I>variable</I>&gt; &lt;END=<I>variable</I>&gt;
&lt;UPDATEMODE=MISSINGCHECK|
<BR>NOMISSINGCHECK&gt;;
<BR><B>BY</B> <I>by-variable</I>;
</TD></TR></TABLE>
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top"><TD>
<IMG border="0" src=" ../common/images/sym02.gif" alt="[2]"><B>MODIFY </B>
<I>master-data-set</I> &lt;(<I>data-set-option(s)</I>)&gt; KEY=<I>index</I> &lt;/ UNIQUE&gt;
&lt;NOBS=<I>variable</I>&gt; &lt;END=<I>variable</I>&gt; ;
</TD></TR></TABLE>
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top"><TD>
<IMG border="0" src=" ../common/images/sym03.gif" alt="[3]"><B>MODIFY </B>
<I>master-data-set</I> &lt;(<I>data-set-option(s)</I>)&gt; &lt;NOBS=<I>variable</I>&gt;  
POINT=<I>variable</I>;
</TD></TR></TABLE>
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top"><TD>
<IMG border="0" src=" ../common/images/sym04.gif" alt="[4]"><B>MODIFY </B> <I>master-data-set</I> &lt;(<I>data-set-option(s)</I>)&gt;
&lt;NOBS=<I>variable</I>&gt; &lt;END=<I>variable</I>&gt;;
</TD></TR></TABLE><DL>
<DT><B><FONT color="FF00007">CAUTION:</FONT></B></DT><DD><B>Damage to the SAS data set can occur if
the system terminates
abnormally during a DATA step that contains the MODIFY statement.</B>

<P>Observations in native SAS data files may have incorrect
data values, or the data file may become unreadable. DBMS tables that are
referenced by views are not affected.&nbsp;&nbsp;<IMG border="0" src="../common/images/cautend.gif" alt="[cautionend]" align="bottom"></DD></DL>
<P><B>Note:</B>&nbsp;&nbsp;&nbsp;
<P>If you modify a password-protected data set, specify
the password with the appropriate data set option (ALTER= or PW=) within the
MODIFY statement, and not in the DATA statement.&nbsp;&nbsp;<IMG border="0" src="../common/images/cautend.gif" alt="[cautionend]" align="bottom"><BR>
<BR><H3><A name="zid-2481">Arguments</A></H3>

<P><A name="z0854698">&#13;</A>
<DL>
<DT><B><B><I>master-data-set</I></B></B></DT>
<DD>specifies the SAS data set that you want
to modify.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Restriction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">This data set must
also appear in the DATA statement.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Restriction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">For sequential and
matching access, the master data set can be a SAS data file, a SAS/ACCESS
view, an SQL view, or a DBMS engine for the LIBNAME statement.  It cannot
be a DATA step view or a passthrough view. 
<P>For random access using POINT=, the master data set must be a SAS data
file or an SQL view that references a SAS data file.  
<P>For direct access using KEY=, the master data set can be a SAS data
file or the DBMS engine for the LIBNAME statement.  If it is a SAS file, it
must be indexed and the index name must be specified on the KEY= option.  
<P>For a DBMS, the KEY= is set to the keyword DBKEY and the column names
to use as an index must be specified on the DBKEY= data set option.  These
column names are used in constructing a WHERE expression that is passed to
the DBMS.</TD>
</TABLE>
<P></DD>

<DT><B><B><I>transaction-data-set</I></B></B></DT>
<DD>specifies the SAS data set that provides
the values for matching access. These values are the values that you want
to use to update the master data set.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Restriction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">Specify this data
set <I><B>only</B></I> when the DATA step contains a BY statement.</TD>
</TABLE>
<P></DD>

<DT><B><A name="z0854706">&#13;END=<B><I>variable</I></B></A></B></DT>
<DD>creates and names a temporary variable that
contains an end-of-file indicator.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Explanation:</B></TD>
<TD align="left" bgcolor="#F5F5F5">The variable, which
is initialized to zero, is set to 1 when the MODIFY statement reads the last
observation of the data set being modified (for sequential access <IMG border="0" src=" ../common/images/sym04.gif" alt="[4]">)
or the last observation of the transaction data set (for matching access <IMG border="0" src=" ../common/images/sym01.gif" alt="[1]">).
It is also set to 1 when MODIFY cannot find a match for a KEY= value (random
access <IMG border="0" src=" ../common/images/sym02.gif" alt="[2]">  <IMG border="0" src=" ../common/images/sym03.gif" alt="[3]">). 
<P>This variable is not added to any data set.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Restriction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">Do not use this
argument in the same MODIFY statement with the POINT= argument. POINT= indicates
that MODIFY uses random access. The value of the END= variable is never set
to 1 for random access.</TD>
</TABLE>
<P></DD>

<DT><B><A name="z0854711">&#13;KEY=<B><I>index</I></B></A></B></DT>
<DD>names a simple or composite index of the
SAS data file that is being modified. The KEY= argument retrieves observations
from that SAS data file based on index values that are supplied by like-named
variables in another source of information.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Default:</B></TD>
<TD align="left" bgcolor="#F5F5F5">If the KEY= value is
not found, the automatic variable _ERROR_ is set to 1, and the automatic variable
_IORC_ receives the value corresponding to the SYSRC autocall macro's mnemonic
_DSENOM. See <A href="#z0173367">Automatic Variable _IORC_ and the SYSRC Autocall Macro</A>
              
.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Restriction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">KEY= processing
is different for SAS/ACCESS engines. See the SAS/ACCESS documentation for
more information.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">Examples of sources for
index values include a separate SAS data set named in a SET statement and
an external file that is read by an INPUT statement.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">If duplicates exist in the
master file, only the first occurrence is updated unless you use a DO-LOOP
to execute a SET statement for the data set listed on the KEY=option for all
duplicates in the master data set.
<P>If duplicates exist in the transaction data set, and they are consequtive,
use the UNIQUE option to force the search for a match in the master data set
to begin at the top of the index. Write an accumulation statement to add each
duplicate transaction to the observation in master.  Without the UNIQUE option,
only the first duplicate transaction observation updates the master.
<P>If the duplicates in the transaction data set are not consecutive, the
search begins at the beginning of the index each time, so that each duplicate
is applied to the master.  Write an accumulation statement to add each duplicate
to the master.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See Also:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0342871">UNIQUE</A></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0173374">Modifying Observations Located by an Index</A>,
<A href="#z0173375">Handling Duplicate Index Values</A>, and <A href="#z0173376">Controlling I/O</A>             </TD>
</TABLE>
<P></DD>

<DT><B><A name="z0854719">&#13;NOBS=<B><I>variable</I></B></A></B></DT>
<DD>creates and names a temporary variable whose
value is usually the total number of observations in the input data set. For
certain SAS views, SAS cannot determine the number of observations. In these
cases, SAS sets the value of the NOBS= variable to the largest positive integer
value available in the operating environment. 
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Explanation:</B></TD>
<TD align="left" bgcolor="#F5F5F5">At compilation time,
SAS reads the descriptor portion of the data set and assigns the value of
the NOBS= variable automatically. Thus, you can refer to the NOBS= variable
before the MODIFY statement. The variable is available in the DATA step but
is not added to the new data set.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">The NOBS= and POINT= options
are independent of each other.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0173373">Modifying Observations Located by Observation Number</A>             </TD>
</TABLE>
<P></DD>

<DT><B><A name="z0854725">&#13;POINT=<B><I>variable</I></B></A></B></DT>
<DD>reads SAS data sets using random (direct)
access by observation number. <B><I>variable</I></B> names
a variable whose value is the number of the observation to read. The POINT=
variable is available anywhere in the DATA step, but it is not added to any
SAS data set. 
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Requirement:</B></TD>
<TD align="left" bgcolor="#F5F5F5">When using the POINT=
argument, include one or both of the following:  
<P>
<UL>

<LI>a STOP statement<P>

<LI>programming logic that checks for an invalid
value
of the POINT= variable.<P>
</UL>
   Because POINT= reads only the specified observations,
SAS cannot detect an end-of-file condition as it would if the file were being
read sequentially.  Because detecting an end-of-file condition terminates
a DATA step automatically, failure to substitute another means of terminating
the DATA step when you use POINT= can cause the DATA step to go into a continuous
loop.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Restriction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">You cannot use the
POINT= option with any of the following:
<P>
<UL>

<LI>BY statement<P>

<LI>WHERE
statement<P>

<LI>WHERE= data set option<P>

<LI>transport format data sets<P>

<LI>sequential data
sets (on tape or disk)<P>

<LI>a table from another vendor's relational database
management system.<P>
</UL>
</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Restriction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">You can use POINT=
with compressed data sets only if the data set was created with the POINTOBS=
data set option set to YES, the default value.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Restriction: </B></TD>
<TD align="left" bgcolor="#F5F5F5">You can use the random access method
on compressed files only with SAS version 7 and beyond. </TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5"> If the POINT= value does
not match an observation number, SAS sets the automatic variable _ERROR_ to
1.  </TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0173373">Modifying Observations Located by Observation Number</A>             </TD>
</TABLE>
<P></DD>

<DT><B><A name="z0854740">&#13;</A><A NAME="z0342871"></A>UNIQUE</B></DT>
<DD>causes a KEY= search always to begin at
the top of the index for the data file being modified. 
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Restriction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">UNIQUE can appear
only with the KEY= option.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">Use UNIQUE when there are
consecutive duplicate KEY= values in the transaction data set, so that the
search for a match in the master data set begins at the top of the index file
for each duplicate transaction.  You must include an accumulation statement
or the duplicate values overwrite each other causing only the last transaction
value to be the result in the master observation. </TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0173375">Handling Duplicate Index Values</A>             </TD>
</TABLE>
<P></DD>

<DT><B><A name="z0854745">&#13;UPDATEMODE=MISSINGCHECK|<BR>UPDATEMODE=NOMISSINGCHECK</A></B></DT>
<DD>specifies whether missing variable values
in a transaction data set are to be allowed to replace existing variable values
in a master data set.
<P>
<DL>
<DT>MISSINGCHECK </DT>
<DD> prevents missing variable values in a transaction
data set from replacing values in a master data set. Special missing values,
however, are the exception and  replace values in the master data set even
when MISSINGCHECK is in effect.<P></DD>

<DT>NOMISSINGCHECK </DT>
<DD>allows missing variable values in a transaction
data set to replace values in a master data set by preventing the check from
being performed.<P></DD>
</DL>

<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Default:</B></TD>
<TD align="left" bgcolor="#F5F5F5">MISSINGCHECK</TD>
</TABLE>
<P></DD>
</DL>


<P><TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><A name="z0163053">Details</A></FONT></B></TD></TR></TABLE>

<BR><H3><A name="z0173362"><IMG border="0" src=" ../common/images/sym01.gif" alt="[1]">Matching Access</A></H3>


<P>The matching access method uses the BY statement to match observations from
the transaction data set with observations in the master data set. The BY
statement specifies a variable that is in the transaction data set and the
master data set.
<P>When the MODIFY statement reads an observation from
the transaction data set, it uses dynamic WHERE processing to locate the matching
observation in the master data set. The observation in the master data set
can be either 
<P>
<UL>

<LI>replaced in the master data set with the value
from the transaction data set<P>

<LI>deleted from the master data set<P>

<LI>appended to the master data
set.<P>
</UL>
 
<P><A href="#z0173372">Modifying Observations Using a Transaction Data Set</A>
               
shows the matching access method.
<BR><H3><A name="z0173363"><IMG border="0" src=" ../common/images/sym01.gif" alt="[1]">Duplicate BY Values</A></H3>


<P>Duplicates in the master and transaction data sets affect processing.
<P>
<UL>

<LI>If
duplicates exist in the master data set, only the first occurrence
is updated because the generated WHERE statement always finds the first occurrence
in the master.<P>

<LI>If duplicates exist in the transaction data set, the duplicates
are applied one on top of another unless you write an accumulation statement
to add all of them to the master observation.  Without the accumulation statement,
the values in the duplicates overwrite each other so that only the value in
the last transaction is the result in the master observation.<P>
</UL>

<BR><H3><A name="z0173364"><IMG border="0" src=" ../common/images/sym02.gif" alt="[2]">Direct Access by Indexed Values</A></H3>


<P>This method requires that you use the KEY= option in the MODIFY
statement to name an indexed variable from the data set that is being modified.
Use another data source (typically a SAS data set named in a SET statement
or an external file read by an INPUT statement) to provide a like-named variable
whose values are supplied to the index. MODIFY uses the index to locate observations
in the data set that is being modified.
<P><A href="#z0173374">Modifying Observations Located by an Index</A>
shows the direct-access-by-indexed-values method.
<BR><H3><A name="z0173365"><IMG border="0" src=" ../common/images/sym02.gif" alt="[2]">Duplicate Index Values</A></H3>


<P> 
<P>
<UL>

<LI>If there are duplicate values of the indexed variable
in the master data set, only the first occurrence is retrieved, modified,
or replaced. Use a DO LOOP to execute a SET statement with the KEY= option
multiple times to update all duplicates with the transaction value.<P>

<LI>If there are duplicate, <B>nonconsecutive</B>
values in the like-named variable in the data source, MODIFY applies each
transaction cumulatively to the first observation in the master data set whose
index value matches the values from the data source. Therefore, only the value
in the last duplicate transaction is the result in the master observation
unless you write an accumulation statement to accumulate each duplicate transaction
value in the master observation.<P>

<LI>If there are duplicate, <B>consecutive</B>
values in the variable in the data source, the values from the first observation
in the data source are applied to the master data set, but the DATA step terminates
with an error when it tries to locate an observation in the master data set
for the second duplicate from the data source. To avoid this error, use the
UNIQUE option in the MODIFY statement. The UNIQUE option causes SAS to return
to the top of the master data set before retrieving a match for the index
value. You must write an accumulation statement to accumulate the values from
all the duplicates. If you do not, only the last one applied is the result
in the master observation.
<P><A href="#z0173375">Handling Duplicate Index Values</A>
shows how to handle duplicate index values.<P>

<LI>If there are duplicate index values in both data
sets, you can use SQL to apply the duplicates in the  transaction data set
to the duplicates in the master data set in a one-to-one correspondence.<P>
</UL>

<BR><H3><A name="z0173366"><IMG border="0" src=" ../common/images/sym03.gif" alt="[3]">Direct (Random) Access by Observation Number</A></H3>


<P>You can use the POINT=  option in the MODIFY statement
to name a variable from another data source (not the master data set), whose
value is the number of an observation that you want to modify in the master
data set. MODIFY uses the values of the POINT= variable to retrieve observations
in the data set that you are modifying. (You can use POINT= on a compressed
data set only if the data set was created with the POINTOBS= data set option.)
<P>It is good programming practice to validate the value
of the POINT= variable and to check the status of the automatic variable _ERROR_. 
<P><A href="#z0173373">Modifying Observations Located by Observation Number</A>
shows the direct (random) access by observation number method.<DL>
<DT><B><FONT color="FF00007">CAUTION:</FONT></B></DT><DD><B>POINT= can result in infinite looping.</B>
Be careful when you use POINT=, as
failure to terminate the
DATA step can cause the DATA step to go into a continuous loop. Use a STOP
statement, programming logic that checks for an invalid value of the POINT=
variable, or both.&nbsp;&nbsp;<IMG border="0" src="../common/images/cautend.gif" alt="[cautionend]" align="bottom"></DD></DL>
<BR><H3><A name="z0343410"><IMG border="0" src=" ../common/images/sym04.gif" alt="[4]">Sequential Access</A></H3>


<P>The sequential access method is the simplest form of the MODIFY statement,
but it provides less control than the direct access methods. With the sequential
access method, you may use the NOBS= and END= options to modify a data set;
you do not use the POINT= or KEY= options.
<BR><H3><A name="z0173367">Automatic Variable _IORC_ and the SYSRC Autocall Macro</A></H3>


<P>The automatic variable _IORC_  contains the return code
for each I/O operation that the MODIFY statement attempts to perform. The
best way to test for values of _IORC_ is with the mnemonic codes that are
provided by the SYSRC autocall macro. Each mnemonic code describes one condition.
The mnemonics provide an easy method for testing problems in a DATA step program.
These codes are useful:
<DL>
<DT>_DSENMR</DT>
<DD>specifies that the transaction data set
observation does not exist on the master data set (used only with MODIFY and
BY statements). If consecutive observations with different BY values do not
find a match in the master data set, both of them return _DSENMR.<P></DD>

<DT>_DSEMTR</DT>
<DD>specifies that multiple transaction data
set observations with a given BY value do not exist on the master data set
(used only with MODIFY and BY statements). If consecutive observations with
the same BY values do not find a match in the master data set, the first observation
returns _DSENMR and the subsequent observations return _DSEMTR.<P></DD>

<DT>_DSENOM</DT>
<DD>specifies that the data set being modified
does not contain the observation that is requested by the KEY= option or the
POINT= option.<P></DD>

<DT>_SENOCHN</DT>
<DD>specifies that SAS is attempting to execute an OUTPUT or
REPLACE statement on an observation that contains a key value which duplicates
one already existing on an indexed data set that requires unique key values. <P></DD>

<DT>_SOK</DT>
<DD>specifies that the observation was located.<P></DD>
</DL>
 
<P><B>Note:</B>&nbsp;&nbsp;&nbsp;Beginning in Version 7, the IORCMSG function returns a formatted
error message associated with the current value of _IORC_.&nbsp;&nbsp;<IMG border="0" src="../common/images/cautend.gif" alt="[cautionend]" align="bottom"><BR>
<P><A href="#z0173376">Controlling I/O</A>
shows how to use the automatic variable _IORC_ and the SYSRC autocall macro.
<BR><H3><A name="z0173368">Writing Observations When MODIFY Is Used in a DATA Step</A></H3>


<P>The way SAS writes observations to a SAS data set when
the DATA step contains a MODIFY statement depends on whether certain other
statements are present. The possibilities are 
<DL>
<DT>no explicit statement</DT>
<DD>writes the current observation to its original
place in the SAS data set. The action occurs as the last action in the step
(as though a REPLACE statement were the last statement in the step).<P></DD>

<DT>OUTPUT statement</DT>
<DD>if no data set is specified in the OUTPUT
statement, writes the current observation to the end of all data sets that
are specified in the DATA step. If a data set is specified, the statement
writes the current observation to the end of the data set that is indicated.
The action occurs at the point in the DATA step where the OUTPUT statement
appears.<P></DD>

<DT>REPLACE &lt;<I>data-set-name</I>>
statement</DT>
<DD>rewrites the current observation in the
specified data set(s), or, if no argument is specified, rewrites the current
observation in each data set specified on the DATA statement.  The action
occurs at the point of the REPLACE statement.<P></DD>

<DT>REMOVE &lt;<I>data-set-name</I>>
statement</DT>
<DD>deletes the current observation in the specified
data set(s), or, if no argument is specified, deletes the current observation
in each data set specified on the DATA statement.  The deletion may be a physical
one or a logical one, depending on the characteristics of the engine that
maintains the data set.<P></DD>
</DL>

<P>Keep in mind the following as you work with these statements:
<P>
<UL>

<LI>When
no OUTPUT, REPLACE, or REMOVE statement is
specified, the default action is REPLACE. <P>

<LI>The OUTPUT, REPLACE, and REMOVE statements are
independent of each other. More than one statement can apply to the same observation,
as long as the sequence is logical. <P>

<LI>Using OUTPUT, REPLACE, or REMOVE in a DATA step
overrides the default replacement of observations. If you use any one of these
statements in a DATA step, you must explicitly program each action that you
want to take.<P>

<LI>If both an OUTPUT statement and a REPLACE or REMOVE
statement execute on a given observation, perform the OUTPUT action last to
keep the position of the observation pointer
correct.<P>
</UL>

<P><A href="#z0173377">Replacing and Removing Observations and Writing Observations to Different SAS Data Sets</A>
shows how to use the OUTPUT, REMOVE, and REPLACE statements to write observations.
<BR><H3><A name="z0173369">Using MODIFY in a SAS/SHARE Environment</A></H3>


<P>In a SAS/SHARE environment, the MODIFY statement accesses
an observation in update mode. That is, the observation is locked from the
time MODIFY reads it until a REPLACE or REMOVE statement executes. At that
point the observation is unlocked. It cannot be accessed until it is re-read
with the MODIFY statement. The MODIFY statement opens the data set in update
mode, but the control level is based on the statement used.  For example,
KEY= and POINT= are member-level locking. Refer to <B>SAS/SHARE User's
Guide</B> for more information.
<P><TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><A name="z0163362">Comparisons</A></FONT></B></TD></TR></TABLE>

<P><A name="z0854806">&#13;</A>
<UL>

<LI>When you use a MERGE, SET, or UPDATE statement
in a DATA step, SAS creates a new SAS data set. The data set descriptor of
the new copy can be different from the old one (variables added or deleted,
labels changed, and so on). When you use a MODIFY statement in a DATA step,
however, SAS does not create a new copy of the data set. As a result, the
data set descriptor cannot change.
<P>For information on DBMS replacement rules, see the SAS/ACCESS
documentation.<P>

<LI>If you use a BY statement with a MODIFY statement,
MODIFY works much like the UPDATE statement, except that 
<P>
<UL>

<LI>neither the master data set nor the transaction
data set needs to be sorted or indexed. (The BY statement that is used with
MODIFY triggers dynamic WHERE processing.) 
<P><B>Note:</B>&nbsp;&nbsp;&nbsp;Dynamic
WHERE processing can be costly if the MODIFY statement modifies a SAS data
set that is not in sorted order or has not been indexed. Having the master
data set in sorted order or indexed and having the transaction data set in
sorted order reduces processing overhead, especially for large files.&nbsp;&nbsp;<IMG border="0" src="../common/images/cautend.gif" alt="[cautionend]" align="bottom"><BR><P>

<LI>both the master data set and the transaction data
set can have observations with duplicate values of the BY variables. MODIFY
treats the duplicates as described in                
<A href="#z0173363"><IMG border="0" src=" ../common/images/sym01.gif" alt="[1]">Duplicate BY Values</A>.<P>

<LI>MODIFY cannot make any changes to the descriptor
information of the data set as UPDATE can. Thus, it cannot add or delete variables,
change variable labels, and so on.<P>
</UL>
<P>
</UL>

<P><TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><A name="z0172442">Input Data Set for Examples</A></FONT></B></TD></TR></TABLE>

<P>The examples modify the INVTY.STOCK data
set. INVTY.STOCK contains these variables:
<DL>
<DT>PARTNO</DT>
<DD>is a character variable with a unique value
identifying each tool number.<P></DD>

<DT>DESC</DT>
<DD>is a character variable with the text description
of each tool.<P></DD>

<DT>INSTOCK </DT>
<DD>is a numeric variable with a value describing
how many units of each tool the company has in stock.<P></DD>

<DT>RECDATE </DT>
<DD>is a numeric variable containing the SAS
date value that is the day for which INSTOCK values are current.<P></DD>

<DT>PRICE</DT>
<DD>is a numeric variable with a value that
describes the unit price for each tool.<P></DD>
</DL>
In
addition, INVTY.STOCK contains a simple index on PARTNO.  This DATA step creates
INVTY.STOCK:



<PRE>libname invty '<I>SAS-data-library</I>';</PRE>






<PRE>options yearcutoff= 1920;

data invty.stock(index=(partno));
   input PARTNO $ DESC $ INSTOCK @17 
         RECDATE date7. @25 PRICE;
   format  recdate date7.;
   datalines;
K89R seal   34  27jul95 245.00
M4J7 sander 98  20jun95 45.88
LK43 filter 121 19may96 10.99
MN21 brace 43   10aug96 27.87
BC85 clamp 80   16aug96 9.55
NCF3 valve 198  20mar96 24.50
KJ66 cutter 6   18jun96 19.77
UYN7 rod  211   09sep96 11.55
JD03 switch 383 09jan97 13.99
BV1E timer 26   03jan97 34.50
;</PRE>
<P><TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><A name="z0173370">Examples</A></FONT></B></TD></TR></TABLE>

<BR><H3> <A name="z0173371">Example 1: Modifying All Observations</A> </H3>


<P>This example replaces the date on all records in the data set INVTY.STOCK
with the current date.  This code replaces the value of the variable RECDATE
with the current date for all observations in INVTY.STOCK: 



<PRE>data invty.stock;
   modify invty.stock;
   recdate=today();
run;</PRE>
<P>A printing of INVTY.STOCK shows that RECDATE has been
modified:




<P>




<TABLE border="1" cellpadding="12" cellspacing="0" bgcolor="#FAFAFA">
<TR>
<TD><PRE>                          INVTY.STOCK                          1

        PARTNO    DESC      INSTOCK    RECDATE     PRICE

         K89R     seal         34      14MAR97    245.00
         M4J7     sander       98      14MAR97     45.88
         LK43     filter      121      14MAR97     10.99
         MN21     brace        43      14MAR97     27.87
         BC85     clamp        80      14MAR97      9.55
         NCF3     valve       198      14MAR97     24.50
         KJ66     cutter        6      14MAR97     19.77
         UYN7     rod         211      14MAR97     11.55
         JD03     switch      383      14MAR97     13.99
         BV1E     timer        26      14MAR97     34.50</PRE></TD></TR></TABLE>

<P>
<P>The MODIFY statement opens INVTY.STOCK for update processing.
SAS reads one observation of INVTY.STOCK for each iteration of the DATA step
and performs any operations that the code specifies.  In this case, the code
replaces the value of RECDATE with the result of the TODAY function for every
iteration of the DATA step. An implicit REPLACE statement at the end of the
step writes each observation to its previous location in INVTY.STOCK.
<BR><H3> <A name="z0173372">Example 2: Modifying Observations Using a Transaction Data Set</A> </H3>


<P>This example adds the quantity of newly received stock
to its data set INVTY.STOCK as well as updating the date on which stock was
received. The transaction data set ADDINV in the WORK library contains the
new data.  
<P>The ADDINV data set is the data set that contains the
updated information. ADDINV contains these variables:
<DL>
<DT>PARTNO </DT>
<DD>is a character variable that corresponds
to the indexed variable PARTNO in INVTY.STOCK.<P></DD>

<DT>NWSTOCK </DT>
<DD>is a numeric variable that represents quantities
of newly received stock for each tool.<P></DD>
</DL>

<P>ADDINV is the second data set in the MODIFY statement.
SAS uses it as the transaction data set and reads each observation from ADDINV
sequentially.  Because the BY statement specifies the common variable PARTNO,
MODIFY finds the first occurrence of the value of PARTNO in INVTY.STOCK that
matches the value of PARTNO in ADDINV. For each observation with a matching
value, the DATA step changes the value of RECDATE to today's date and replaces
the value of INSTOCK with the sum of INSTOCK and NWSTOCK (from ADDINV). MODIFY
does not add NWSTOCK to the INVTY.STOCK data set because that would modify
the data set descriptor. Thus, it is not necessary to put NWSTOCK in a DROP
statement. 
<P>This example specifies ADDINV as the transaction data
set that contains information to modify INVTY.STOCK. A BY statement specifies
the shared variable whose values locate the observations in INVTY.STOCK.  
<P>This DATA step creates ADDINV:



<PRE>data addinv;
   input PARTNO $ NWSTOCK;
   datalines;
K89R 55
M4J7 21
LK43 43
MN21 73
BC85 57
NCF3 90
KJ66 2
UYN7 108
JD03 55
BV1E 27
;</PRE>
<P>This DATA step uses values from ADDINV to update INVTY.STOCK.



<PRE>libname invty '<I>SAS-data-library</I>';</PRE>



<PRE>data invty.stock;
   modify invty.stock addinv;
   by partno;
   RECDATE=today();
   INSTOCK=instock+nwstock;
   if _iorc_=0 then replace;
run;</PRE>
<P>A printing of INVTY.STOCK shows that INSTOCK and RECDATE
have been modified:




<P>





<TABLE border="1" cellpadding="12" cellspacing="0" bgcolor="#FAFAFA">
<TR>
<TD><PRE>                          INVTY.STOCK                1

        PARTNO    DESC      INSTOCK    RECDATE     PRICE

         K89R     seal         89      14MAR97    245.00
         M4J7     sander      119      14MAR97     45.88
         LK43     filter      164      14MAR97     10.99
         MN21     brace       116      14MAR97     27.87
         BC85     clamp       137      14MAR97      9.55
         NCF3     valve       288      14MAR97     24.50
         KJ66     cutter        8      14MAR97     19.77
         UYN7     rod         319      14MAR97     11.55
         JD03     switch      438      14MAR97     13.99
         BV1E     timer        53      14MAR97     34.50</PRE></TD></TR></TABLE>

<P>
<BR><H3> <A name="z0173373">Example 3: Modifying Observations Located by Observation Number</A> </H3>


<P>This example reads the data set NEWP, determines which
observation number in INVTY.STOCK to update based on the value of TOOL_OBS,
and performs the update.  This example explicitly specifies the update activity
by using an assignment statement to replace the value of PRICE with the value
of NEWP. 
<P>The data set  NEWP contains two variables: 
<DL>
<DT>TOOL_OBS </DT>
<DD>contains the observation number of each
tool in the tool company's master data set, INVTY.STOCK.<P></DD>

<DT>NEWP</DT>
<DD>contains the new price for each tool.<P></DD>
</DL>

<P>This DATA step creates NEWP:



<PRE>data newp;
   input TOOL_OBS NEWP;
   datalines;
 251.00
2 49.33
3 12.32
4 30.00
5 15.00
6 25.75
7 22.00
8 14.00
9 14.32
0 35.00
;</PRE>
<P>This DATA step updates INVTY.STOCK:



<PRE>libname invty '<I>SAS-data-library</I>';</PRE>



<PRE>data invty.stock;
   set newp;
   modify invty.stock point=tool_obs
          nobs=max_obs;
   if _error_=1 then
      do;
        put 'ERROR occurred for TOOL_OBS=' tool_obs /
        'during DATA step iteration' _n_ /
        'TOOL_OBS value may be out of range.';
        _error_=0;
        stop;
      end;
   PRICE=newp;
   RECDATE=today();
run;</PRE>
<P>A printing of INVTY.STOCK  shows that RECDATE and PRICE
have been modified:




<P>





<TABLE border="1" cellpadding="12" cellspacing="0" bgcolor="#FAFAFA">
<TR>
<TD><PRE>                          INVTY.STOCK                1

        PARTNO    DESC      INSTOCK    RECDATE     PRICE

         K89R     seal         34      14MAR97    251.00
         M4J7     sander       98      14MAR97     49.33
         LK43     filter      121      14MAR97     12.32
         MN21     brace        43      14MAR97     30.00
         BC85     clamp        80      14MAR97     15.00
         NCF3     valve       198      14MAR97     25.75
         KJ66     cutter        6      14MAR97     22.00
         UYN7     rod         211      14MAR97     14.00
         JD03     switch      383      14MAR97     14.32
         BV1E     timer        26      14MAR97     35.00</PRE></TD></TR></TABLE>

<P>
<BR><H3> <A name="z0173374">Example 4: Modifying Observations Located by an Index</A> </H3>


<P>This example uses the KEY= option to identify observations
to retrieve by matching the values of PARTNO from ADDINV with the indexed
values of PARTNO in INVTY.STOCK. ADDINV is created in <A href="#z0173372">Modifying Observations Using a Transaction Data Set</A>.
<P>KEY= supplies index values that allow
MODIFY to access
directly the observations to update. No dynamic WHERE processing occurs. In
this example, you specify that the value of INSTOCK in the master data set
INVTY.STOCK increases by the value of the variable NWSTOCK from the transaction
data set ADDINV.
<P>
<PRE>libname invty '<I>SAS-data-library</I>';</PRE>



<PRE>data invty.stock;
   set addinv;
   modify invty.stock key=partno;
   INSTOCK=instock+nwstock;
   RECDATE=today();
   if _iorc_=0 then replace;
run;</PRE>
<P>A printing of INVTY.STOCK shows that INSTOCK and RECDATE
have been modified.




<P>





<TABLE border="1" cellpadding="12" cellspacing="0" bgcolor="#FAFAFA">
<TR>
<TD><PRE>                          INVTY.STOCK                1

        PARTNO    DESC      INSTOCK    RECDATE     PRICE

         K89R     seal         89      14MAR97    245.00
         M4J7     sander      119      14MAR97     45.88
         LK43     filter      164      14MAR97     10.99
         MN21     brace       116      14MAR97     27.87
         BC85     clamp       137      14MAR97      9.55
         NCF3     valve       288      14MAR97     24.50
         KJ66     cutter        8      14MAR97     19.77
         UYN7     rod         319      14MAR97     11.55
         JD03     switch      438      14MAR97     13.99
         BV1E     timer        53      14MAR97     34.50</PRE></TD></TR></TABLE>

<P>
<BR><H3> <A name="z0173375">Example 5: Handling Duplicate Index Values</A> </H3>


<P>This example shows how MODIFY handles duplicate values of the variable in
the SET data set that is supplying values to the index on the master data
set.
<P>The NEWINV data set is the data set that contains the
updated information. NEWINV contains these variables:
<DL>
<DT>PARTNO </DT>
<DD>is a character variable that corresponds
to the indexed variable PARTNO in INVTY.STOCK. The NEWINV data set contains
duplicate values for PARTNO; <B><CODE><FONT size="+1">M4J7</FONT></CODE></B> appears twice.<P></DD>

<DT>NWSTOCK </DT>
<DD>is a numeric variable that represents quantities
of newly received stock for each tool.<P></DD>
</DL>

<P>This DATA step creates NEWINV:
<PRE>data newinv;
   input PARTNO $ NWSTOCK;
   datalines;
K89R 55
M4J7 21
M4J7 26
LK43 43
MN21 73
BC85 57
NCF3 90
KJ66 2
UYN7 108
JD03 55
BV1E 27
;</PRE>
<P>This DATA step terminates with an error when it tries
to locate an observation in INVTY.STOCK  to match with the second occurrence
of <B><CODE><FONT size="+1">M4J7</FONT></CODE></B> in NEWINV:
<PRE>libname invty '<I>SAS-data-library</I>';</PRE>
<PRE>/* This DATA step terminates with an error! */
data invty.stock;
   set newinv;
   modify invty.stock key=partno;
   INSTOCK=instock+nwstock;
   RECDATE=today();
run;</PRE>
<P>This message appears in the SAS log:
<P>
<P>
<TABLE border="1" cellpadding="12" cellspacing="0" bgcolor="#FAFAFA">
<TR>
<TD><PRE>ERROR: No matching observation was found in MASTER data set.
PARTNO=K89R NWSTOCK=55 DESC=  INSTOCK=. RECDATE=14MAR97 PRICE=.
_ERROR_=1 _IORC_=1230015 _N_=1
NOTE: Missing values were generated as a result of performing 
      an operation on missing values.
      Each place is given by: 
      (Number of times) at (Line):(Column).
      1 at 689:19   
NOTE: The SAS System stopped processing this step because of 
      errors.
NOTE: The data set INVTY.STOCK has been updated.  There were 0 
      observations rewritten, 0 observations added and 0 
      observations deleted.</PRE></TD></TR></TABLE>

<P>
<P>Adding the UNIQUE option to the MODIFY statement avoids
the error in the previous DATA step. The UNIQUE option causes the DATA step
to return to the top of the index each time it looks for a match for the value
from the SET data set. Thus, it finds the <B><CODE><FONT size="+1">M4J7</FONT></CODE></B>
in the MASTER data set for each occurrence of <B><CODE><FONT size="+1">M4J7</FONT></CODE></B>
in the SET data set. The updated result for <B><CODE><FONT size="+1">M4J7</FONT></CODE></B>
in the output shows that both values of NWSTOCK from NEWINV for <B><CODE><FONT size="+1">M4J7</FONT></CODE></B> are added to the value of INSTOCK for <B><CODE><FONT size="+1">M4J7</FONT></CODE></B> in INVTY.STOCK. An
accumulation statement sums the values;
 without it, only the value of the last instance of <B><CODE><FONT size="+1">M4J7</FONT></CODE></B>
would be the result in INVTY.STOCK.
<PRE>data invty.stock;
   set newinv;
   modify invty.stock key=partno / unique;
   INSTOCK=instock+nwstock;
   RECDATE=today();
   if _iorc_=0 then replace;
run; </PRE>
<P>A printing of INVTY.STOCK shows that INSTOCK and RECDATE
have been modified:
<P>
<P>





<TABLE border="1" cellpadding="12" cellspacing="0" bgcolor="#FAFAFA">
<TR>
<TD><PRE>               Results of Using the UNIQUE Option    1

        PARTNO    DESC      INSTOCK    RECDATE     PRICE

         K89R     seal         89      14MAR97    245.00
         M4J7     sander      145      14MAR97     45.88
         LK43     filter      164      14MAR97     10.99
         MN21     brace       116      14MAR97     27.87
         BC85     clamp       137      14MAR97      9.55
         NCF3     valve       288      14MAR97     24.50
         KJ66     cutter        8      14MAR97     19.77
         UYN7     rod         319      14MAR97     11.55
         JD03     switch      438      14MAR97     13.99
         BV1E     timer        53      14MAR97     34.50</PRE></TD></TR></TABLE>

<P>
<BR><H3> <A name="z0173376">Example 6: Controlling I/O</A> </H3>


<P>This example
uses the SYSRC autocall macro and the _IORC_ automatic variable to control
I/O condition. This technique helps to prevent unexpected results that could
go undetected. This example uses the direct access method with an index to
update INVTY.STOCK. The data in the NEWSHIP data set updates  INVTY.STOCK. 
<P>This DATA step creates NEWSHIP:
<PRE>options yearcutoff= 1920; 

data newship;
   input PARTNO $ DESC $ NWSTOCK @17 
         SHPDATE date7. @25 NWPRICE;
   datalines;
K89R seal 14    14nov96 245.00
M4J7 sander 24  23aug96 47.98
LK43 filter 11  29jan97 14.99
MN21 brace 9    09jan97 27.87
BC85 clamp 12   09dec96 10.00
ME34 cutter 8   14nov96 14.50
;</PRE>
<P>Each WHEN clause in the SELECT statement specifies actions
for each input/output return code that is returned by the SYSRC autocall macro:
<P>
<UL>

<LI>_SOK indicates that the MODIFY statement executed
successfully. <P>

<LI>_DSENOM indicates that no matching observation
was found in INVTY.STOCK. The OUTPUT statement specifies that the observation
be appended to INVTY.STOCK. See the last observation in the output.<P>

<LI>If any other code is returned by SYSRC, the DATA
step terminates and the PUT statement writes the message to the log.  <P>
</UL>

<PRE>libname invty '<I>SAS-data-library</I>';</PRE>
<PRE>data invty.stock;
   set newship;
   modify invty.stock key=partno;
   select (_iorc_);
      when (%sysrc(_sok)) do;
         INSTOCK=instock+nwstock;
         RECDATE=shpdate;
         PRICE=nwprice;
         replace;
      end;
      when (%sysrc(_dsenom)) do;
         INSTOCK=nwstock;
         RECDATE=shpdate;
         PRICE=nwprice;
         output;
         _error_=0;
      end;
      otherwise do;
         put
         'An unexpected I/O error has occurred.'/
         'Check your data and your program';
         _error_=0;
         stop;
       end;
   end;
run;</PRE>
<P>





<TABLE border="1" cellpadding="12" cellspacing="0" bgcolor="#FAFAFA">
<TR>
<TD><PRE>                      INVTY.STOCK Data Set           1

        PARTNO    DESC      INSTOCK    RECDATE     PRICE

         K89R     seal         48      14NOV96    245.00
         M4J7     sander      122      23AUG96     47.98
         LK43     filter      132      29JAN97     14.99
         MN21     brace        52      09JAN97     27.87
         BC85     clamp        92      09DEC96     10.00
         NCF3     valve       198      20MAR96     24.50
         KJ66     cutter        6      18JUN96     19.77
         UYN7     rod         211      09SEP96     11.55
         JD03     switch      383      09JAN97     13.99
         BV1E     timer        26      03JAN97     34.50
         ME34     cutter        8      14NOV96     14.50</PRE></TD></TR></TABLE>

<P>
<BR><H3> <A name="z0173377">Example 7: Replacing and Removing Observations and Writing Observations to Different SAS Data Sets</A> </H3>


<P>This example shows
that you can replace and remove (delete) observations and write observations
to different data sets. Further, this example shows that if an OUTPUT, REPLACE,
or REMOVE statement is present, you must specify explicitly what action to
take because no default statement is generated. 
<P>The parts that were received in 1997 are output to INVTY.STOCK97
and are removed from INVTY.STOCK. Likewise, the parts that were received in
1995 are output to INVTY.STOCK95 and are removed from INVTY.STOCK. Only the
parts that were received in 1996 remain in INVTY.STOCK, and the PRICE is updated
only in INVTY.STOCK. 
<PRE>libname invty '<I>SAS-data-library</I>';</PRE>
<PRE>data invty.stock invty.stock95 invty.stock97;
   modify invty.stock;
   if recdate>'01jan97'd then do;
       output invty.stock97;
       remove invty.stock;
   end;
   else if recdate&lt;'01jan96'd then do;
       output invty.stock95;
       remove invty.stock;
   end;
   else do; 
      price=price*1.1;
      replace invty.stock;
   end; 
run;</PRE>
<P>




<TABLE border="1" cellpadding="12" cellspacing="0" bgcolor="#FAFAFA">
<TR>
<TD><PRE>                New Prices for Stock Rcvd in '96     1

        PARTNO    DESC      INSTOCK    RECDATE     PRICE

         LK43     filter      121      19MAY96    12.089
         MN21     brace        43      10AUG96    30.657
         BC85     clamp        80      16AUG96    10.505
         NCF3     valve       198      20MAR96    26.950
         KJ66     cutter        6      18JUN96    21.747
         UYN7     rod         211      09SEP96    12.705</PRE></TD></TR></TABLE>

<P>
<TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><FONT size="5"><A name="z0173378">See Also</A></FONT>
</FONT></B></TD></TR></TABLE>
<P>
<TABLE cellpadding="6" cellspacing="2">
<TR valign="top"><TD></TD><TD>Statements:
<P>
<TABLE cellpadding="6" cellspacing="2">
<TR valign="top"><TD></TD><TD><A href="z0194540.htm">OUTPUT</A></TD></TR>
<TR valign="top"><TD></TD><TD><A href="z0202648.htm">REMOVE</A></TD></TR>
<TR valign="top"><TD></TD><TD><A href="z0201991.htm">REPLACE</A></TD></TR>
<TR valign="top"><TD></TD><TD><A href="z0202975.htm">UPDATE</A></TD></TR></TABLE></TD></TR>
<TR valign="top"><TD></TD><TD>"Reading,
Combining, and Modifying SAS Data Sets"
in                
<B>SAS Language Reference: Concepts</B></TD></TR>
<TR valign="top"><TD></TD><TD>"SQL Procedure" in the  
<B>SAS Procedures Guide</B></TD></TR></TABLE>

<P><!-- navigation -->
<P><TABLE cellpadding="0" cellspacing="0">
<TR valign="top">
<TD align="center">
<A href="z0293668.htm">
<IMG border="0" SRC="../common/images/cont1.gif"><BR><FONT size="-2">Chapter Contents</FONT></A></TD>
<TD align="center">
<A href="z0227561.htm">
<IMG border="0" src="../common/images/prev1.gif"><BR><FONT size="-2">Previous</FONT></A></TD>
<TD align="center">
<A href="z0289429.htm">
<IMG border="0" SRC="../common/images/next1.gif"><BR><FONT size="-2">Next</FONT></A></TD>
<TD align="center">
<A href="#z0173361">
<IMG border="0" SRC="../common/images/top1.gif"><BR><FONT size="-2">Top of Page</FONT></A></TD>
</TR></TABLE>
<P><FONT size=1><A href="../common/images/copyrite.htm">Copyright 1999 by SAS Institute Inc., Cary, NC, USA. All rights reserved.</A></FONT>
</BODY>
</HTML>