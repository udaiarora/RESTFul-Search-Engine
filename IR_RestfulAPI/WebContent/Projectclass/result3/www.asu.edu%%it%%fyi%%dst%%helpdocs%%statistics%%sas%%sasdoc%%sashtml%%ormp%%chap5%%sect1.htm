<HTML>
<HEAD>
<TITLE>Overview</TITLE>
<LINK REL="STYLESHEET" TYPE="text/css" HREF="../sas.css">
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<A NAME="nlpoverview">&#13;</A>
<!--Navigation Panel-->
<TABLE BORDER="0" CELLPADDING="0">
<TR VALIGN="TOP">
  <TD ALIGN="CENTER">
  <A NAME="topofpage" HREF="index.htm">
  <IMG BORDER="0" SRC="../../common/images/cont1.gif" ALT="Chapter Contents" WIDTH="99" HEIGHT="16"><BR><FONT SIZE="-2">Chapter Contents</FONT></A></TD>
  <TD ALIGN=CENTER>
  <A HREF="index.htm"><IMG BORDER="0" SRC="../../common/images/prev1.gif" ALT="Previous" WIDTH="99" HEIGHT="16"><BR><FONT SIZE="-2">Previous</FONT></A></TD>
  <TD ALIGN=CENTER>
  <A HREF="sect2.htm"><IMG BORDER="0" SRC="../../common/images/next1.gif" ALT="Next" WIDTH="99" HEIGHT="16"><BR><FONT SIZE="-2">Next</FONT></A></TD>
</TR>
</TABLE>
<TABLE BGCOLOR="#CCCC99" WIDTH="100%" CELLPADDING=4>
<TR>
  <TD VALIGN=MIDDLE CLASS="chaphead"><I><FONT SIZE="2">The NLP Procedure</FONT></I></TD>
</TR>
</TABLE><BR>
<P><!--End of Navigation Panel-->
<H1><FONT SIZE="5">Overview</FONT></H1>
<A NAME="idxnlp0001">&#13;</A><A NAME="idxnlp0002">&#13;</A>The NLP procedure (<B>N</B>on<B>L</B>inear <B>P</B>rogramming)
offers a set of optimization techniques for minimizing or
maximizing a continuous nonlinear function <SPAN CLASS="mathfont"><I>f</I>(<I>x</I>)</SPAN> of <SPAN CLASS="mathfont"><I>n</I></SPAN>
decision variables, <SPAN CLASS="mathfont"><I>x</I> = (<I>x<SUb>1</SUb></I>, ... ,<I>x</I><sub><I>n</I></sub>)<sup><I>T</I></sup></SPAN> with lower and upper bound,
linear and nonlinear, equality and inequality
constraints. This can be expressed as solving 

<DL CLASS="equation"><DD><IMG WIDTH="351" HEIGHT="146"
 SRC="images/nlpeq1.gif"
 ALT="& \min_{x \in {\cal R}^n} f(x) & \ {subject to} & c_i(x) = 0 & i = 1, ... ,m_e \ & c_i(x) \ge 0 & i = m_e+1, ... ,m \ & u_i \ge x_i \ge l_i & i = 1, ... ,n
 "></DL>
where <SPAN CLASS="mathfont"><I>f</I></SPAN> is the objective function, the <SPAN CLASS="mathfont"><I>c</I><SUB><I>i</I></SUB></SPAN>'s are 
the nonlinear functions,
and <SPAN CLASS="mathfont"><I>u</I><SUB><I>i</I></SUB></SPAN>, <SPAN CLASS="mathfont"><I>l</I><SUB><I>i</I></SUB></SPAN>'s are the upper and lower bounds.
Problems of this type are found in many settings ranging from
optimal control to maximum likelihood estimation.
<P>The NLP procedure provides a number of algorithms for solving
this problem that take advantage of special structure on
the objective function and constraints.
One example is the quadratic programming problem:
<DL CLASS="equation"><DD><IMG WIDTH="406" HEIGHT="131"
 SRC="images/nlpeq2.gif"
 ALT="f(x) = {1 \over 2} x^T G x + g^T x + b \{subject to} & c_i(x) = 0 & i = 1, ... ,m_e "></DL>
where the <SPAN CLASS="mathfont"><I>c</I><SUB><I>i</I></SUB>(<I>x</I>)</SPAN>'s are linear functions;
<SPAN CLASS="mathfont"><I>g</I> = (<I>g<SUb>1</SUb></I>, ... ,<I>g</I><sub><I>n</I></sub>)<sup><I>T</I></sup></SPAN> and <SPAN CLASS="mathfont"><I>b</I> = (<I>b<SUb>1</SUb></I>, ... ,<I>b</I><sub><I>n</I></sub>)<sup><I>T</I></sup></SPAN> are vectors and
<SPAN CLASS="mathfont"><I>G</I></SPAN> is an <SPAN CLASS="mathfont"><I>n</I> &times;<I>n</I></SPAN> symmetric matrix.
<P>Another example is the least-squares problem:
<DL CLASS="equation"><DD><IMG WIDTH="448" HEIGHT="131"
 SRC="images/nlpeq3.gif"
 ALT="f(x) = {1 \over 2} \{f^2_1(x) +  ...  + f^2_l(x)\} \{subject to} & c_i(x) = 0 & i = 1, ... ,m_e "></DL>
where the <SPAN CLASS="mathfont"><I>c</I><SUB><I>i</I></SUB>(<I>x</I>)</SPAN>'s are linear functions, 
and <SPAN CLASS="mathfont"><I>f<SUB>1</SUB></I>(<I>x</I>),...,<I>f</I><SUB><I>m</I></SUB>(<I>x</I>)</SPAN> are nonlinear functions of <SPAN CLASS="mathfont"><I>x</I></SPAN>.  <BR>
<P>The following problems are handled by PROC NLP.
<UL>
<LI> quadratic programming with an option for sparse problems
<LI> unconstrained minimization/maximization
<LI> constrained minimization/maximization
<LI> linear complementarity problem     
</UL>
<P>The following optimization techniques are supported in PROC NLP.
<UL>
<LI> Quadratic Active Set Technique
<LI> Trust-Region Method
<LI> Newton-Raphson Method With Line-Search
<LI> Newton-Raphson Method With Ridging
<LI> Quasi-Newton Methods
<LI> Double-Dogleg Method
<LI> Conjugate Gradient Methods
<LI> Nelder-Mead Simplex Method
<LI> Levenberg-Marquardt Method
<LI> Hybrid Quasi-Newton Methods
</UL>
<P>These optimization techniques require
a continuous objective function <SPAN CLASS="mathfont"><I>f</I></SPAN>, and all but
one (NMSIMP) require continuous first-order derivatives of the
objective function <SPAN CLASS="mathfont"><I>f</I></SPAN>. 
Some of the techniques also require
continuous second-order derivatives. 
There are three ways to compute derivatives in PROC NLP:
<UL>
<LI> analytically (using a special derivative compiler), the default method
<LI> via finite difference approximations
<LI> via user-supplied exact or approximate numerical functions
</UL>
<P>Nonlinear programs can be input into the procedure
in various ways.
The objective, constraint, and derivative functions are
specified using the programming statements of PROC NLP.
In addition, information in SAS data sets can be used to define
the structure of objectives and constraints as well as specify
constants used in objectives, constraints and derivatives.
<P>PROC NLP uses data sets to input various pieces of information.
<UL>
<LI> The DATA= data set enables you to specify data shared by 
all functions involved in a least-squares problem.
<LI> The INQUAD= data set contains the arrays appearing in a 
quadratic programming problem.
<LI> The INVAR= data set 
specifies initial values for the decision variables,
the values of constants that are referred
to in the program statements, and simple boundary and
general linear constraints.
<LI> The MODEL= data set specifies a model (functions, constraints, 
derivatives) saved at a previous execution of the NLP procedure.
</UL>
<P>PROC NLP uses data sets to output various results.
<UL>
<LI>
The OUTVAR= data set 
saves the values of the decision variables, the derivatives, 
the solution, and the covariance matrix at the solution.
<LI>
The OUT= output data set contains 
variables generated in the program statements defining the 
objective function as well as selected variables of the 
DATA= input data set, if available.
<LI>
The OUTMODEL= data
set saves the programming statements. It can be used to 
input a model in the MODEL= input data set.
</UL><P>
<!--Navigation Panel-->
<TABLE BORDER="0" CELLPADDING="0">
<TR VALIGN="TOP">
  <TD ALIGN="CENTER">
  <A HREF="index.htm">
  <IMG BORDER="0" SRC="../../common/images/cont1.gif" ALT="Chapter Contents" WIDTH="99" HEIGHT="16"><BR><FONT SIZE="-2">Chapter Contents</FONT></A></TD>
  <TD ALIGN=CENTER>
  <A HREF="index.htm"><IMG BORDER="0" SRC="../../common/images/prev1.gif" ALT="Previous" WIDTH="99" HEIGHT="16"><BR><FONT SIZE="-2">Previous</FONT></A></TD>
  <TD ALIGN=CENTER>
  <A HREF="sect2.htm"><IMG BORDER="0" SRC="../../common/images/next1.gif" ALT="Next" WIDTH="99" HEIGHT="16"><BR><FONT SIZE="-2">Next</FONT></A></TD>
  <TD ALIGN=CENTER>
  <A HREF="#topofpage">
  <IMG BORDER="0" SRC="../../common/images/top1.gif" ALT="Top" WIDTH="99" HEIGHT="16"><BR><FONT SIZE="-2">Top</FONT></A></TD>
</TR>
</TABLE>
<P><!--End of Navigation Panel-->
<P><FONT SIZE="1"><A HREF="../../common/images/copyrite.htm">Copyright &copy; 1999 by SAS Institute Inc., Cary, NC, USA. All rights reserved.</A></FONT>
</BODY>
</HTML>
