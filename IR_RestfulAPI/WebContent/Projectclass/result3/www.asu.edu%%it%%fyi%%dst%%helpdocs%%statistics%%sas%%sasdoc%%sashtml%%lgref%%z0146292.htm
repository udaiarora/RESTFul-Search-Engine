<HTML>
<!-- This page produced Mon Jul 19 13:58:41 EDT 1999
 -->
<!-- Used program version 1.118.1.2 from beta -->
<HEAD>
<!-- <META http-equiv="Content-Type" content="text/html; charset="> -->
<TITLE>Statements : INPUT </TITLE></HEAD>
<BODY bgcolor="#FFFFFF">
<!-- navigation -->
<TABLE cellpadding="0" cellspacing="0">
<TR valign="top">
<TD align="center">
<A href="z0293668.htm">
<IMG border="0" SRC="../common/images/cont1.gif"><BR><FONT size="-2">Chapter Contents</FONT></A></TD>
<TD align="center">
<A href="z0178244.htm">
<IMG border="0" src="../common/images/prev1.gif"><BR><FONT size="-2">Previous</FONT></A></TD>
<TD align="center">
<A href="z0148066.htm">
<IMG border="0" SRC="../common/images/next1.gif"><BR><FONT size="-2">Next</FONT></A></TD>
</TR></TABLE>
<!-- running head -->
<TABLE width="100%" cellpadding="4">
<TR valign="MIDDLE">
<TD bgcolor="#CCCC99"><I><FONT size="2">INPUT</FONT></I></TD>
</TR>
</TABLE><H1><FONT size="5"><A name="z0146292">INPUT</A></FONT></H1>

<P><HR><BR><B>Describes the arrangement of values in the input data record and
assigns input values to the corresponding SAS variables</B><p>

<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="right" bgcolor="#F5F5F5" nowrap><B>Valid:</B></TD>
<TD bgcolor="#CCCCCC" align="left">in a DATA step
</TD></TR>
<TR valign="top">
<TD align="right" bgcolor="#F5F5F5" nowrap><B>Category:</B></TD>
<TD bgcolor="#CCCCCC" align="left">File-handling
</TD></TR>
<TR valign="top">
<TD align="right" bgcolor="#F5F5F5" nowrap><B>Type:</B></TD>
<TD bgcolor="#CCCCCC" align="left">Executable
</TD></TR>
</TABLE><HR>
<TABLE cellspacing="0" cellpadding="1">
<TR>
<TD colspan="2"><A href="z0146292.htm#zid-2398"><FONT size="2"><B>Syntax</b></FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0146292.htm#z0207329"><FONT size="2"><B>Syntax Description</b></FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146292.htm#z0207330"><FONT size="2">Without Arguments</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146292.htm#z0146302"><FONT size="2">Arguments</FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0146292.htm#z0207331"><FONT size="2"><B>Details</b></FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146292.htm#z0207332"><FONT size="2">When to Use INPUT</FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0146292.htm#z0207333"><FONT size="2"><B>Input Styles</b></FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146292.htm#z0146618"><FONT size="2">Column Input</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146292.htm#z0146620"><FONT size="2">List Input</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146292.htm#z0146619"><FONT size="2">Formatted Input</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146292.htm#z0207334"><FONT size="2">Named Input</FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0146292.htm#z0207335"><FONT size="2"><B>Multiple Styles in a Single INPUT Statement</b></FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0146292.htm#z0146294"><FONT size="2"><B>Pointer Controls</b></FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146292.htm#z0207336"><FONT size="2">Using Column and Line Pointer Controls</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146292.htm#z0146300"><FONT size="2">Using Line-Hold Specifiers</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146292.htm#z0207337"><FONT size="2">Pointer Location After Reading</FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0146292.htm#z0146495"><FONT size="2"><B>Reading More Than One Record per Observation</b></FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146292.htm#z0207338"><FONT size="2">Reading Past the End of a Line</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146292.htm#z0207339"><FONT size="2">Positioning the Pointer Before the Record</FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0146292.htm#z0148554"><FONT size="2"><B>How Invalid Data are Handled</b></FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0146292.htm#z0207340"><FONT size="2"><B>End-of-File</b></FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0146292.htm#z0207341"><FONT size="2"><B>Arrays</b></FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0146292.htm#z0207342"><FONT size="2"><B>Comparisons</b></FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0146292.htm#z0146399"><FONT size="2"><B>Examples</b></FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146292.htm#z0146293"><FONT size="2">Example 1: Using Multiple Styles of Input in One INPUT Statement</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146292.htm#z0146291"><FONT size="2">Example 2: Using a Null INPUT Statement</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146292.htm#z0146299"><FONT size="2">Example 3: Holding a Record in the Input Buffer</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146292.htm#z0146304"><FONT size="2">Example 4: Holding a Record Across Iterations of the DATA Step</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146292.htm#z0146306"><FONT size="2">Example 5: Positioning the Pointer with a Numeric Variable</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146292.htm#z0146296"><FONT size="2">Example 6: Positioning the Pointer with a Character Variable</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146292.htm#z0146305"><FONT size="2">Example 7: Moving the Pointer Backward</FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0146292.htm#z0207343"><FONT size="2"><B>See Also</b></FONT></A></TD></TR></TABLE>
<TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><H2><A name="zid-2398">Syntax</A></H2></TD></TR></TABLE>

<TABLE cellpadding="4" cellspacing="2">
<TR valign="top"><TD>
<B>INPUT</B>
&lt;<I>specification(s)</I>&gt;&lt;@|@@&gt;;
</TD></TR></TABLE><A name="zid-2399">&#13;</A>
<P><A name="z0854070">&#13;</A>
<P><TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><A name="z0207329">Syntax Description</A></FONT></B></TD></TR></TABLE>

<BR><H3><A name="z0207330">Without Arguments</A></H3>


<P>The INPUT
statement with no arguments is called a <B>null INPUT statement</B>. 
<DL>
<DT>The null input statement</DT>
<DD>
<UL>

<LI>brings an input data record into the input buffer
without creating any SAS variables<P>

<LI>releases an input data record that is held by
a trailing @ or a double trailing @.<P>
</UL>

<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0146291">Using a Null INPUT Statement</A></TD>
</TABLE>
<P></DD>
</DL>

<BR><H3><A name="z0146302">Arguments</A></H3>


<P>
<DL>
<DT><I><B>specification</B></I></DT>
<DD>can include
<P>
<DL>
<DT><I><B>variable</B></I></DT>
<DD>names a variable that is assigned input
values.<P></DD>

<DT>(<I><B>variable-list</B></I>)</DT>
<DD>specifies a list of variables that are assigned
input values.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Requirement:</B></TD>
<TD align="left" bgcolor="#F5F5F5">The (<I>variable-list</I>) is followed by an (<I>informat-list</I>).</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See
Also:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="z0148073.htm#z0148113">How to Group Variables and Informats</A></TD>
</TABLE>
<P></DD>

<DT><A name="z0854085">&#13;$</A></DT>
<DD>indicates to store the variable value as
a character value rather than as a numeric value.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">If the variable is previously
defined as character, $ is not required.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0146293">Using Multiple Styles of Input in One INPUT Statement</A></TD>
</TABLE>
<P></DD>

<DT><I><B>pointer-control</B></I></DT>
<DD>moves the input pointer to a specified line
or column in the input buffer.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0146301">Column Pointer Controls</A> and
<A href="#z0146303">Line Pointer Controls</A></TD>
</TABLE>
<P></DD>

<DT><I><B>column-specifications</B></I></DT>
<DD>specifies the columns of the input record
that contain the value to read.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0146618">Column Input</A></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0146293">Using Multiple Styles of Input in One INPUT Statement</A></TD>
</TABLE>
<P></DD>

<DT><I><B>format-modifier</B></I></DT>
<DD>allows modified list input or controls the
amount of information that is reported in the SAS log when an error in an
input value occurs.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">Use modified list input
to read data that cannot be read with simple list input.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="z0144370.htm#z0148116">When to Use List Input</A></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0146295">Format Modifiers for Error Reporting</A></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0146296">Positioning the Pointer with a Character Variable</A></TD>
</TABLE>
<P></DD>

<DT><I><B>informat.</B></I></DT>
<DD>specifies an informat to use to read the
variable value.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">You can use modified list
input to read data with informats. This is useful when the data require informats
but cannot be read with formatted input because the values are not aligned
in columns.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0146619">Formatted Input</A> and
<A href="#z0146620">List Input</A></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="z0148073.htm#z0148159">Using Informat Lists</A></TD>
</TABLE>
<P></DD>

<DT>(<I><B>informat-list</B></I>)</DT>
<DD>specifies a list of informats to use to
read the values for the preceding list of variables.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Restriction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">The (<I><B>informat-list</B></I>) must follow the
(<I><B>variable-list</B></I>).</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="z0148073.htm#z0148113">How to Group Variables and Informats</A></TD>
</TABLE>
<P></DD>
</DL>
<P></DD>

<DT><A name="z0854111">&#13;@</A></DT>
<DD>holds an input record for the execution
of the next INPUT statement within the same iteration of the DATA step. This
line-hold specifier is called <B>trailing @</B>.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Restriction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">The trailing @ must
be the last item in the INPUT statement.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">The trailing @ prevents
the next INPUT statement from automatically releasing the current input record
and reading the next record into the input buffer. It is useful when you need
to read from a record multiple times.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See Also:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0146300">Using Line-Hold Specifiers</A></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0146299">Holding a Record in the Input Buffer</A></TD>
</TABLE>
<P></DD>

<DT><A name="z0854117">&#13;@@</A></DT>
<DD>holds the input record for the execution
of the next INPUT statement across iterations of the DATA step. This line-hold
specifier is called <B>double trailing @</B>.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Restriction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">The double trailing
@ must be the last item in the INPUT statement.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">The  double trailing @ is
useful when each input line contains values for several observations.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See Also:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0146300">Using Line-Hold Specifiers</A></TD>
</TABLE>

<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0146304">Holding a Record Across Iterations of the DATA Step</A></TD>
</TABLE>
<P></DD>
</DL>

<BR><H3><A name="z0146301">Column Pointer Controls</A></H3>


<P><A name="z0854123">&#13;</A>
<DL>
<DT><A name="z0854124">&#13;@<I><B>n</B></I></A></DT>
<DD>moves the pointer to column <I>n</I>.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Range:</B></TD>
<TD align="left" bgcolor="#F5F5F5">a positive integer</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">If <I>n</I>
is not an integer, SAS truncates the decimal value and uses only the integer
value. If <I>n</I> is zero or negative, the pointer
moves to column 1.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Example:</B></TD>
<TD align="left" bgcolor="#F5F5F5">@15 moves the pointer
to column 15:



<PRE>input @15 name $10.;</PRE></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0146305">Moving the Pointer Backward</A></TD>
</TABLE>
<P></DD>

<DT>@<I><B>numeric-variable</B></I></DT>
<DD>moves the pointer to the column given by
the value of <I>numeric-variable</I>.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Range:</B></TD>
<TD align="left" bgcolor="#F5F5F5">a positive integer</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">If <I>numeric-variable</I> is not an integer, SAS truncates the decimal value and only
uses the integer value. If  <I>numeric-variable</I>
is zero or negative, the pointer moves to column 1.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Example:</B></TD>
<TD align="left" bgcolor="#F5F5F5">The value of the variable
A moves the pointer to column 15:



<PRE>a=15;
input @a name $10.;</PRE></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0146306">Positioning the Pointer with a Numeric Variable</A></TD>
</TABLE>
<P></DD>

<DT>@(<I><B>expression</B></I>)</DT>
<DD>moves the pointer to the column that is
given by the value of <I>expression</I>.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Restriction:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><I>Expression</I> must result in a positive integer.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">If the value of <I>expression</I> is not an integer, SAS truncates the decimal value
and only uses the integer value. If it is zero or negative, the pointer moves
to column 1.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Example:</B></TD>
<TD align="left" bgcolor="#F5F5F5">The result of the expression
moves the pointer to column 15:



<PRE>b=5;
input @(b*3) name $10.;</PRE></TD>
</TABLE>
<P></DD>

<DT>@'<I><B>character-string</B></I>'</DT>
<DD>locates the specified series of characters
in the input record and moves the pointer to the first column after
<I>character-string</I>.<P></DD>

<DT>@<I><B>character-variable</B></I></DT>
<DD>locates the series of characters in the
input record that is given by the value of <I>character-variable</I> and moves the pointer to the first column after that series
of characters.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Example:</B></TD>
<TD align="left" bgcolor="#F5F5F5">The following statement
reads in the WEEKDAY character variable. The second @1 moves the pointer to
the beginning of the input line. The value for SALES is read from the next
nonblank column after the value of WEEKDAY:



<PRE>input @1 day 1. @5 weekday $10.
      @1 @weekday sales 8.2;</PRE></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0146296">Positioning the Pointer with a Character Variable</A></TD>
</TABLE>
<P></DD>

<DT>@(<I><B>character-expression</B></I>)</DT>
<DD>locates the series of characters in the
input record that is given by the value of <I>character-expression</I> and moves the pointer to the first column after the series.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0146296">Positioning the Pointer with a Character Variable</A></TD>
</TABLE>
<P></DD>

<DT><A name="z0854150">&#13;+<I><B>n</B></I></A></DT>
<DD>moves the pointer <I>n</I>
columns.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Range:</B></TD>
<TD align="left" bgcolor="#F5F5F5">a positive integer or
zero</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">If <I>n</I>
is not an integer, SAS truncates the decimal value and uses only the integer
value. If the value is greater than the length of the input buffer, the pointer
moves to column 1 of the next record. </TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Example:</B></TD>
<TD align="left" bgcolor="#F5F5F5">This statement moves
the pointer to column 23, reads a value for LENGTH from columns 23 through
26, advances the pointer five columns, and reads a value for WIDTH from columns
32 through 35:



<PRE>input @23 length 4. +5 width 4.;</PRE></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0146305">Moving the Pointer Backward</A></TD>
</TABLE>
<P></DD>

<DT>+<I><B>numeric-variable</B></I></DT>
<DD>moves the pointer the number of columns
that is given by the value of <I>numeric-variable</I>.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Range:</B></TD>
<TD align="left" bgcolor="#F5F5F5">a positive or negative
integer or zero</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">If <I>numeric-variable</I> is not an integer, SAS truncates the decimal value and uses
only the integer value. If <I>numeric-variable</I> is
negative, the pointer moves backward. If the current column position becomes
less than 1, the pointer moves to column 1. If the value is zero, the pointer
does not move. If the value is greater than the length of the input buffer,
the pointer moves to column 1 of the next record.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0146305">Moving the Pointer Backward</A></TD>
</TABLE>
<P></DD>

<DT>+(<I><B>expression</B></I>)</DT>
<DD>moves the pointer the number of columns
given by <I>expression</I>.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Range:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><I>expression</I> must result in a positive or negative integer or zero.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">If <I>expression</I> is not an integer, SAS truncates the decimal value and uses
only the integer value. If <I>expression</I> is negative,
the pointer moves backward. If the current column position becomes less than
1, the pointer moves to column 1. If the value is zero, the pointer does not
move. If the value is greater than the length of the input buffer, the pointer
moves to column 1 of the next record.</TD>
</TABLE>
<P></DD>
</DL>

<BR><H3><A name="z0146303">Line Pointer Controls</A></H3>


<P><A name="z0854165">&#13;</A>
<DL>
<DT><A name="z0854166">&#13;#<I><B>n</B></I></A></DT>
<DD>moves the pointer to record <I>n</I>.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Range:</B></TD>
<TD align="left" bgcolor="#F5F5F5">a positive integer</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Interaction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">The N= option in
the INFILE statement can affect the number of records the INPUT statement
reads and the placement of the input pointer after each iteration of the DATA
step. See the option <A href="z0146932.htm#z0167032">N=</A>.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Example:</B></TD>
<TD align="left" bgcolor="#F5F5F5">The #2 moves the pointer
to the second record to read the value for ID from columns 3 and 4:



<PRE>input name $10. #2 id 3-4;</PRE></TD>
</TABLE>
<P></DD>

<DT>#<I><B>numeric-variable</B></I></DT>
<DD>moves the pointer to the record that is
given by the value of <I>numeric-variable</I>.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Range:</B></TD>
<TD align="left" bgcolor="#F5F5F5">a positive integer</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">If the value of <I>numeric-variable</I> is not an integer, SAS truncates the decimal
value and uses only the integer value. </TD>
</TABLE>
<P></DD>

<DT>#(<I><B>expression</B></I>)</DT>
<DD>moves the pointer to the record that is
given by the value of <I>expression</I>.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Range:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><I>expression</I> must result in a positive integer.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">If the value of <I>expression</I> is not an integer, SAS truncates the decimal value
and uses only the integer value. </TD>
</TABLE>
<P></DD>

<DT><A name="z0854179">&#13;/</A></DT>
<DD>advances the pointer to column 1 of the
next input record.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Example:</B></TD>
<TD align="left" bgcolor="#F5F5F5">The values for NAME
and AGE are read from the first input record before the pointer moves to the
second record to read the value of ID from columns 3 and 4:



<PRE>input name age / id 3-4;</PRE></TD>
</TABLE>
<P></DD>
</DL>

<BR><H3><A name="z0146295">Format Modifiers for Error Reporting</A></H3>


<P>
<DL>
<DT><A name="z0854183">&#13;?</A></DT>
<DD>suppresses printing the invalid data note
when SAS encounters invalid data values.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See
Also:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0148554">How Invalid Data are Handled</A></TD>
</TABLE>
<P></DD>

<DT><A name="z0854186">&#13;??</A></DT>
<DD>suppresses printing the messages and the
input lines when SAS encounters invalid data values. The automatic variable
_ERROR_  is not set to 1 for the invalid observation.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See
Also:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0148554">How Invalid Data are Handled</A></TD>
</TABLE>
<P></DD>
</DL>


<P><TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><A name="z0207331">Details</A></FONT></B></TD></TR></TABLE>

<BR><H3><A name="z0207332">When to Use INPUT</A></H3>


<P>Use the
INPUT statement to read raw data from an external file or in-stream data.
If your data are stored in an external file, you can specify the file in an
INFILE statement. The INFILE statement must execute before the INPUT statement
that reads the data records. If your data are in-stream, a DATALINES statement
must precede the data lines in the job stream. If your data contain semicolons,
use a DATALINES4 statement before the data lines. A DATA step that reads raw
data can include multiple INPUT statements.
<P>You can also use the INFILE statement to read in-stream
data by specifying a filename of DATALINES on the INFILE statement before
the INPUT statement. This allows you to use most of the options available
on the INFILE statement with in-stream data.
<P>To read data that are already stored in a SAS data set,
use a SET statement. To read database or PC file-format data that are created
by other software, use the SET statement after you access the data with the
LIBNAME statement. See the SAS/ACCESS documentation for more information.
<P><TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><A name="z0207333">Input Styles</A></FONT></B></TD></TR></TABLE>

<P>There are four
ways to describe a record's values in the INPUT statement: 
<P>
<UL>

<LI>column<P>

<LI>list (simple and
modified)<P>

<LI>formatted<P>

<LI>named.<P>
</UL>
Each variable value is read by using one of these input
styles.
An INPUT statement may contain any or all of the available input styles, depending
on the arrangement of data values in the input records. However, once named
input is used in an INPUT statement, you cannot use another input style.
<BR><H3><A name="z0146618">Column Input</A></H3>


<P><A name="z0854197">&#13;With
<B>column input</B>, the column numbers follow
the variable name in the INPUT statement. These numbers  indicate where the
variable values are found in the input data records:  


</A>
<PRE>input name $ 1-8 age 11-12;</PRE>


This INPUT statement can read the following data records: 



<PRE>----+----1----+----2----+
Peterson  21
Morgan    17</PRE>


Because NAME is a character variable, a $ appears between
the variable name and column numbers. For more information, see <A href="z0148066.htm">INPUT, Column</A>.
<BR><H3><A name="z0146620">List Input</A></H3>


<P><A name="z0854198">&#13;With
<B>list input</B>, the variable names are simply
listed in the INPUT statement. A $ follows the name of each character variable:
 


</A>
<PRE>input name $ age;</PRE>


This INPUT statement can read data values that are
separated by blanks or aligned in columns (with at least one blank between): 



<PRE>----+----1----+----2----+
Peterson  21
Morgan  17</PRE>


For more information, see <A href="z0144370.htm">INPUT, List</A>.
<BR><H3><A name="z0146619">Formatted Input</A></H3>


<P><A name="z0854199">&#13;With <B>formatted input</B>, an informat
follows the variable name in the INPUT statement. The informat gives the data
type and the field width of an input value. Informats also allow you to read
data that are stored in nonstandard form, such as packed decimal, or numbers
that contain special characters such as commas.   


</A>
<PRE>input name $char8. +2 age 2.;</PRE>


This INPUT statement reads these data records correctly: 



<PRE>----+----1----+----2----+
Peterson  21
Morgan    17</PRE>


The pointer control of +2 moves the input pointer to the
field that contains the value for the variable AGE. For more information,
see <A href="z0148073.htm">INPUT, Formatted</A>.
<BR><H3><A name="z0207334">Named Input</A></H3>


<P><A name="z0854200">&#13;With
<B>named input</B>, you specify the name of
the variable followed by an equal sign. SAS looks for a variable name and
an equal sign in the input record:  


</A>
<PRE>input name= $ age=;</PRE>


This
INPUT statement reads the following data records correctly: 



<PRE>----+----1----+----2----+
name=Peterson age=21
name=Morgan age=17</PRE>


For more information, see <A href="z0148147.htm">INPUT, Named</A>.
<P><TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><A name="z0207335">Multiple Styles in a Single INPUT Statement</A></FONT></B></TD></TR></TABLE>

<P>An INPUT statement can contain any or all of the different
input styles:  



<PRE>input idno name $18. team $ 25-30 startwght endwght;</PRE>


This
INPUT statement reads the following data records correctly: 



<PRE>----+----1----+----2----+----3----+----
023 David Shaw         red    189 165
049 Amelia Serrano     yellow 189 165</PRE>


The value of IDNO, STARTWGHT,
and ENDWGHT are read with list input, the value of NAME with formatted input,
and the value of TEAM with column input.
<P>
<P><B>Note:</B>&nbsp;&nbsp;&nbsp;Once named input is used
in an INPUT statement, you cannot change input styles. &nbsp;&nbsp;<IMG border="0" src="../common/images/cautend.gif" alt="[cautionend]" align="bottom"><BR>
<P><TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><A name="z0146294">Pointer Controls</A></FONT></B></TD></TR></TABLE>

<P><A name="z0854204">&#13;As SAS reads values
from the input data records into the input buffer, it keeps track of its position
with a pointer. The INPUT statement provides three ways to control the movement
of the pointer:</A>
<DL>
<DT>column pointer controls </DT>
<DD>reset the pointer's column position when
the data values in the data records are read. <P></DD>

<DT>line pointer controls </DT>
<DD>reset the pointer's line position when the
data values in the data records are read. <P></DD>

<DT>line-hold specifiers</DT>
<DD>hold an input record in the input buffer
so that another INPUT statement can process it. By default, the INPUT statement
releases the previous record and reads another record.<P></DD>
</DL>

<P>With column and line pointer controls, you can specify
an absolute  line number or column number to  move the pointer or you can
specify a column or line location relative to the current pointer position. <A href="#z0146647">Pointer Controls Available in the INPUT Statement</A>
lists the pointer controls that are available with the INPUT statement.
<P>
<TABLE cellpadding="6" cellspacing="0" border="0">
<CAPTION align="top"><B><I><A name="z0146647">Pointer Controls Available in the INPUT Statement</A></I></B></CAPTION>


<TR valign="bottom" bgcolor="#CCCCCC">
  <TH  align="LEFT" valign="BOTTOM" ><B><A name="z0146647">&#13;Pointer Controls</A></B></TH>
  <TH  align="LEFT" valign="BOTTOM" ><B>Relative </B></TH>
  <TH  align="LEFT" valign="BOTTOM" ><B>Absolute </B></TH>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD  align="LEFT" valign="TOP">column pointer controls</TD>
  
<TD  align="LEFT" valign="TOP">+<I><B>n</B></I></TD>
  
<TD  align="LEFT" valign="TOP">@<I><B>n</B></I></TD>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD  align="LEFT" valign="TOP"><BR></TD>
  
<TD  align="LEFT" valign="TOP">+<I><B>numeric-variable</B></I></TD>
  
<TD  align="LEFT" valign="TOP">@<I><B>numeric-variable</B></I></TD>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD ><BR></TD>
  
<TD  align="LEFT" valign="TOP">+(<I><B>expression</B></I>)</TD>
  
<TD  align="LEFT" valign="TOP">@<I><B>(expression)</B></I></TD>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD ><BR></TD>
  
<TD ><BR></TD>
  
<TD  align="LEFT" valign="TOP">@'<I><B>character-string</B></I>'</TD>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD ><BR></TD>
  
<TD ><BR></TD>
  
<TD  align="LEFT" valign="TOP">@<I><B>character-variable</B></I></TD>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD  align="LEFT" valign="TOP"><BR></TD>
  
<TD ><BR></TD>
  
<TD  align="LEFT" valign="TOP">@(<I><B>character-expression</B></I>)</TD>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD  align="LEFT" valign="TOP">line pointer controls </TD>
  
<TD  align="LEFT" valign="TOP">/</TD>
  
<TD  align="LEFT" valign="TOP">#<I><B>n</B></I></TD>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD  align="LEFT" valign="TOP"><BR></TD>
  
<TD  align="LEFT" valign="TOP"><BR></TD>
  
<TD  align="LEFT" valign="TOP">#<I><B>numeric-variable</B></I></TD>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD  align="LEFT" valign="TOP"><BR></TD>
  
<TD ><BR></TD>
  
<TD  align="LEFT" valign="TOP">#(<I><B>expression</B></I>)</TD>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD  align="LEFT" valign="TOP">line-hold specifiers</TD>
  
<TD  align="LEFT" valign="TOP">@ </TD>
  
<TD  align="LEFT" valign="TOP">(not applicable)</TD>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD  align="LEFT" valign="TOP"><BR></TD>
  
<TD  align="LEFT" valign="TOP">@@ </TD>
  
<TD  align="LEFT" valign="TOP">(not applicable)</TD>
</TR>

</TABLE>

<BR>
<P><B>Note:</B>&nbsp;&nbsp;&nbsp;Always specify pointer controls before
the variable to which they apply. &nbsp;&nbsp;<IMG border="0" src="../common/images/cautend.gif" alt="[cautionend]" align="bottom"><BR>
<P>You can use the COLUMN= and LINE= options in the INFILE
statement to determine the pointer's current column and line location.
<BR><H3><A name="z0207336">Using Column and Line Pointer Controls</A></H3>


<P>Column pointer controls indicate the column in which an input value
starts.
<P>Use line pointer controls at the end of the INPUT statement
to move to the next input record or to define the number of input records
per observation. Line pointer controls specify which input record to read.
To  read multiple data records into the input buffer, use the N= option in
the INFILE statement to specify the number of records. If you omit N=, you
need to take special precautions. For more information, see <A href="#z0146495">Reading More Than One Record per Observation</A>.
<BR><H3><A name="z0146300">Using Line-Hold Specifiers</A></H3>


<P><A name="z0854246">&#13;Line-hold
specifiers keep the pointer on the current input record when </A>
<P>
<UL>

<LI>a data record is read by more than one INPUT statement
(trailing @)<P>

<LI>one input line has values for more than one observation
(double  trailing @).<P>
</UL>
Use a single trailing @ to allow the next INPUT statement
to read from the same record. Use a double trailing @ to hold a record for
the next INPUT statement across iterations of the DATA step. 
<P>Normally, each INPUT statement in a DATA step reads
a new data record into the input buffer. When you use a trailing @, the following
occurs: 
<P>
<UL>

<LI>The pointer position does not change.<P>

<LI>No new record is read into the input
buffer.<P>

<LI>The next INPUT statement for the same iteration
of the DATA step continues to read the same record rather than a new one.<P>
</UL>

<P>SAS releases a record held by a trailing @ when

<P>
<UL>

<LI>a null INPUT statement executes:



<PRE>input;</PRE><P>

<LI>an INPUT statement without a trailing @ executes<P>

<LI>the next iteration of the DATA step
begins.<P>
</UL>

<P>Normally, when you use a double trailing @ (@@), the
INPUT statement for the next iteration of the DATA step continues to read
the same record. SAS releases the record that is held by a double trailing
@ 
<P>
<UL>

<LI>immediately if the pointer moves past the end
of the input record<P>

<LI>immediately if a null INPUT statement executes:



<PRE>input;</PRE><P>

<LI>when the next iteration of the DATA step begins
if an INPUT statement with a single trailing @ executes later in the DATA
step:



<PRE>input @;</PRE><P>
</UL>

<BR><H3><A name="z0207337">Pointer Location After Reading</A></H3>


<P> Understanding the location of the input pointer after a value is read is
important, especially if you combine input styles in a single INPUT statement.
With column and formatted input, the pointer reads the columns that are indicated
in the INPUT statement and stops in the next column. With list input, however,
the pointer scans data records to locate data values and reads a blank to
indicate that a value has ended. After reading a value with list input, the
pointer stops in the second column after the value.
<P>For example, you can read these data records with list,
column, and formatted input: 



<PRE>----+----1----+----2----+----3
REGION1    49670
REGION2    97540
REGION3    86342</PRE>
<P>This INPUT statement uses list input to read the data
records:  



<PRE>input region $ jansales;</PRE>


After reading a value for
REGION, the pointer stops in column 9. 



<PRE>----+----1----+----2----+----3
REGION1    49670
        &uarr;</PRE>
<P> These INPUT statements use column and formatted input
to read the data records: 
<P>
<UL>

<LI>column input



<PRE>input region $ 1-7 jansales 12-16;</PRE><P>

<LI>formatted input



<PRE>input region $7. +4 jansales 5.;</PRE><P>
</UL>
To read a value for the variable REGION, both INPUT statements
instruct the pointer to read 7 columns and stop in column 8. 



<PRE>----+----1----+----2----+----3
REGION1    49670
       &uarr;</PRE>
<P><TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><A name="z0146495">Reading More Than One Record per Observation</A></FONT></B></TD></TR></TABLE>

<P><A name="z0854267">&#13;The highest
number that follows the # pointer control in the
INPUT statement determines how many input data records are read into the input
buffer. Use the N= option in the INFILE statement to change the number of
records. For example, in this statement, the highest value after the # is
3:  


</A>
<PRE>input @31 age 3. #3 id 3-4 #2 @6 name $20.;</PRE>


Unless
you use N=  in the associated INFILE statement, the INPUT statement reads
three input records each time the DATA step executes.
<P>When each observation has multiple input records but
values from the last record are not read, you must use a # pointer control
in the INPUT statement or N= in the INFILE statement to specify the last input
record. For example, if there are four records per observation, but only values
from the first two input records are read, use this INPUT statement:  



<PRE>input name $ 1-10 #2 age 13-14 #4;</PRE>
<P>When you have advanced to the next record with the /
pointer control, use the # pointer control in the INPUT statement or the N=
option in the INFILE statement to set the number of records that are read
into the input buffer. To move the pointer back to an earlier record, use
a # pointer control. For example, this statement requires the #2 pointer control,
unless the INFILE statement uses the N= option, to read two records:  



<PRE>input a / b #1 @52 c #2;</PRE>


The INPUT statement assigns A a value from
the first record. The pointer advances to the next input record to assign
B a value. Then the pointer returns from the second record to column 1 of
the first record and moves to column 52  to assign C a value. The #2 pointer
control identifies two input records for each observation so that the pointer
can return to the first record for the value of C.
<P>If the number of input records per observation varies,
use the N= option in the INFILE statement to give the maximum number of records
per observation. For more information, see the <A href="z0146932.htm#z0167032">N= option</A>.
<BR><H3><A name="z0207338">Reading Past the End of a Line</A></H3>


<P>When you use @ or + pointer controls with a value that moves the pointer to
or past the end of the current record and the next value is to be read from
the current column, SAS goes to column 1 of the next record to read it. It
also writes this message to the SAS log:  



<PRE>NOTE: SAS went to a new line when INPUT statement
      reached past the end of a line.</PRE>


You can alter the default behavior
(the FLOWOVER option) in the INFILE statement. 
<P>Use the <A href="z0146932.htm#z0166995">STOPOVER option </A> in the INFILE statement to
treat this condition as an error and to stop building the data set. 
<P>Use the <A href="z0146932.htm#z0166987">MISSOVER option</A> in the
INFILE statement to set
the remaining INPUT statement variables to missing values if the pointer reaches
the end of a record.
<P>Use the <A href="z0146932.htm#z0166997">TRUNCOVER option</A> in the INFILE statement to read
column input or formatted input when the last variable that is read by the
INPUT statement contains varying-length data.
<BR><H3><A name="z0207339">Positioning the Pointer Before the Record</A></H3>


<P>When a column pointer control tries to move the pointer to
a position before the beginning of the record, the pointer is positioned in
column 1. For example, this INPUT statement specifies that the pointer is
located in column -2 after the first value is read:  



<PRE>data test;
   input a @(a-3) b;
   datalines;
 2
;</PRE>


Therefore, SAS moves the pointer to column 1 after the value of A
is read. Both variables A and B contain the same value.
<P><TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><A name="z0148554">How Invalid Data are Handled</A></FONT></B></TD></TR></TABLE>

<P><A name="z0854276">&#13;When SAS encounters
an invalid character in an input value for the variable indicated, it </A>
<P>
<UL>

<LI>sets the value of the variable that is being read
to missing or the value that is specified with the INVALIDDATA= system option.
For more information see <A href="z0210381.htm">INVALIDDATA=</A>.<P>

<LI>prints an invalid data note in the SAS
log.<P>

<LI>prints the input line and column number that contains
the invalid value in the SAS log. Unprintable characters appear in hexadecimal.
To help determine column numbers, SAS prints a rule line above the input line.<P>

<LI>sets the automatic variable _ERROR_ to 1 for the
current observation.<P>
</UL>
 
<P>The format modifiers for error reporting control the
amount of information that is printed in the SAS log. Both the ? and ?? modifier
suppress the invalid data message. However, the ?? modifier also resets the
automatic variable _ERROR_  to 0. For example, these two sets of statements
are equivalent: 
<P>
<UL>

<LI>
<PRE>input x ?? 10-12;</PRE><P>

<LI>
<PRE>input x ? 10-12; 
_error_=0;</PRE><P>
</UL>
In either case, SAS  sets invalid values of X to missing
values. For information on the causes of invalid data, see          
 <B>SAS Language Reference: Concepts</B>.
<P><TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><A name="z0207340">End-of-File</A></FONT></B></TD></TR></TABLE>
End-of-file
occurs when an INPUT statement reaches the end of the data. If a DATA step
tries to read another record after it reaches an end-of-file then execution
stops. If you want the DATA step to continue to execute, use the END= or EOF=
 option in the INFILE statement. Then you can write SAS program statements
to detect the end-of-file, and to stop the execution of the INPUT statement
but continue with the DATA step. For more information, see <A href="z0146932.htm">INFILE</A>.
<P><TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><A name="z0207341">Arrays</A></FONT></B></TD></TR></TABLE>

<P>The INPUT statement
can use array references to read input data values. You can use an array reference
in a pointer control if it is enclosed in parentheses. See <A href="#z0146296">Positioning the Pointer with a Character Variable</A>.
<P>Use the array subscript
asterisk (*) to input all elements
of a previously defined explicit array. SAS allows  single or multidimensional
arrays. Enclose the subscript in braces, brackets, or parentheses. The form
of this statement is



<PRE>INPUT <I>array-name</I>{*};</PRE>
<P>You can use arrays with list, column, or formatted input.
However, you cannot input values to an array that is defined with _TEMPORARY_
and that uses the asterisk subscript. For example, these statements create
variables X1 through X100 and assign data values to the variables using the
2. informat:  



<PRE>array x{100};
input x{*} 2.;</PRE>
<P><TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><A name="z0207342">Comparisons</A></FONT></B></TD></TR></TABLE>

<P><A name="z0854286">&#13;</A>
<P>
<UL>

<LI>The INPUT
statement reads raw data in external
files or data lines that are entered in-stream (following the DATALINES statement)
that need to be described to SAS. The SET statement reads a SAS data set,
which already contains descriptive information about the data values.<P>

<LI>The INPUT statement reads data while the PUT statement
writes data values and/or text strings to the SAS log or to an external file.<P>

<LI>The INPUT statement can read data from external
files; the INFILE statement points to that file and has options that control
how that file is read.<P>
</UL>

<P><TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><A name="z0146399">Examples</A></FONT></B></TD></TR></TABLE>

<BR><H3> <A name="z0146293">Example 1: Using Multiple Styles of Input in One INPUT Statement</A> </H3>


<P>This example uses several
input styles in a single INPUT statement:  



<PRE>data club1;
   input Idno Name $18.
         Team $ 25-30 Startwght Endwght;
   datalines;
023 David Shaw         red    189 165
049 Amelia Serrano     yellow 189 165
... <I>more data lines</I> ...
;</PRE>


 
<P>
<TABLE cellpadding="6" cellspacing="0" border="0">


<TR valign="bottom" bgcolor="#CCCCCC">
  <TH  colspan="2" align="LEFT" valign="BOTTOM" ><B>The values for ...</B></TH>
  <TH  align="LEFT" valign="BOTTOM" ><B>Are read with ...</B></TH>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD  colspan="2" align="LEFT" valign="TOP">Idno, Startwght, Endwght</TD>
  
<TD  align="LEFT" valign="TOP">list input</TD>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD  colspan="2" align="LEFT" valign="TOP">Name</TD>
  
<TD  align="LEFT" valign="TOP">formatted input</TD>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD  colspan="2" align="LEFT" valign="TOP">Team</TD>
  
<TD  align="LEFT" valign="TOP">column input</TD>
</TR>

</TABLE>

<BR>
<BR><H3> <A name="z0146291">Example 2: Using a Null INPUT Statement</A> </H3>


<P>This example uses an INPUT statement with no arguments. The DATA step copies
records from the input file to the output file without creating any SAS variables:
 



<PRE>data _null_;
   infile <I>file-specification-1</I>;
   file <I>file-specification-2</I>;
   input;
   put _infile_;
run;</PRE>
<BR><H3> <A name="z0146299">Example 3: Holding a Record in the Input Buffer</A> </H3>


<P>This example reads a file that contains two kinds of input data records and
creates a SAS data set from these records. One type of data record contains
information about a particular college course. The second type of record contains
information about the students enrolled in the course. You need two INPUT
statements to read the two records and to assign the values to different variables
that use different formats. Records that contain class information have a
C in column 1; records that contain student information have an S in column
1, as shown here: 



<PRE>----+----1----+----2----+
C HIST101 Watson
S Williams 0459
S Flores   5423
C MATH202 Sen
S Lee      7085</PRE>
<P>To know which INPUT statement to use, check each record
as it is read. Use an INPUT statement that reads only the variable that tells
whether the record contains class or student.  






<PRE>data schedule(drop=type);
   infile <I>file-specification; </I> 
   retain Course Professor;
   input type $ 1 @;
   if type='C' then 
      input course $ professor $;
   else if type='S' then 
      do;
        input Name $10. Id;
        output schedule;
      end;
run;</PRE>



<PRE>proc print; 
run;</PRE>





The first INPUT statement reads the TYPE value from column 1 of every
line. Because this INPUT statement ends with a trailing @, the next INPUT
statement in the DATA step reads the same line. The IF-THEN statements that
follow check whether the record is a class or student line before another
INPUT statement reads the rest of the line. The INPUT statements without a
trailing @ release the held line. The RETAIN statement saves the values about
the particular college course. The DATA step writes an observation to the
SCHEDULE data set after a student record is read.
<P>The following output that PROC PRINT generates shows
the resulting data set  SCHEDULE.
<P>
<P>
<B><I>Data Set Schedule</I></B><BR>





<TABLE border="1" cellpadding="12" cellspacing="0" bgcolor="#FAFAFA">
<TR>
<TD><PRE>                         The SAS System                        1

        OBS    Course     Professor    Name         Id

         1     HIST101     Watson      Williams     459
         2     HIST101     Watson      Flores      5423
         3     MATH202     Sen         Lee         7085</PRE></TD></TR></TABLE>

<P>
<BR><H3> <A name="z0146304">Example 4: Holding a Record Across Iterations of the DATA Step</A> </H3>


<P>This example shows how to create multiple observations
for each input data record. Each record contains several NAME and AGE values.
The DATA step reads a NAME value and an AGE value, outputs an observation,
then reads another set of NAME and AGE values to output, and so on until all
the input values in the record are processed. <A NAME="z0146562"></A>



<PRE>data test;
   input name $ age @@;
   datalines;
John 13 Monica 12 Sue 15 Stephen 10
Marc 22 Lily 17
;</PRE>


The INPUT statement uses the double trailing @ to control the input
pointer across iterations of the DATA step.  The SAS data set contains six
observations.
<BR><H3> <A name="z0146306">Example 5: Positioning the Pointer with a Numeric Variable</A> </H3>


<P>This example uses a numeric variable to position the
pointer. A raw data file contains records with the employment figures for
several offices of a multinational company. The input data records are



<PRE>----+----1----+----2----+----3----+
8      New York    1 USA 14
5   Cary           1 USA 2274
3 Chicago          1 USA 37
22 Tokyo           5 ASIA 80
5   Vancouver      2 CANADA 6
9       Milano     4 EUROPE 123</PRE>The first column has the column position
for the office location. The next numeric column is the region category. The
geographic region occurs before the number of employees in that office.
<P>You determine the office location by combining the @<B>numeric-variable</B> pointer control
with a trailing @. To read the records,
use two INPUT statements. The first INPUT statement obtains the value for
the @ <B>numeric-variable</B> pointer control. The second INPUT statement
uses this value  to determine the column that the pointer moves to. 



<PRE>data office (drop=x);
   infile <I>file-specification; </I>
   input x @;
   if 1&lt;=x&lt;=10 then
      input @x City $9.;
   else do;
      put 'Invalid input at line ' _n_;
      delete;
   end;
run;</PRE>
<P>The DATA step writes only five observations to the OFFICE
data set. The fourth input data record is invalid because the value of X is
greater than 10. Therefore, the second INPUT statement does not execute. Instead,
the PUT statement writes a message to the SAS log and the DELETE statement
stops processing the observation.
<BR><H3> <A name="z0146296">Example 6: Positioning the Pointer with a Character Variable</A> </H3>


<P>This example uses character variables to position the
pointer. The OFFICE data set, created in <A href="#z0146562">Example 5 </A>, contains a character variable
CITY whose values are the office locations.  Suppose you discover that you
need to read additional values from the raw data file. By using another DATA
step, you can combine the @<B>character-variable</B> pointer control
with a trailing @ and the @<B>character-expression</B> pointer control
to locate the values.
<P>If the observations in OFFICE are still in the order
of the original input data records, you can use this DATA step:  



<PRE>data office2;
   set office;
   infile <I>file-specification</I>;
   array region {5} $ _temporary_
         ('USA' 'CANADA' 'SA' 'EUROPE' 'ASIA');
   input @city Location : 2. @;
   input @(trim(region{location})) Population : 4.;
run;</PRE>The ARRAY statement assigns initial values to the temporary array elements.
These elements correspond to the geographic regions of the office locations.
The first INPUT statement uses an @<B>character-variable</B> pointer
control. Each record is scanned for the series of characters in the value
of CITY for that observation. Then the value of LOCATION is read from the
next nonblank column.  LOCATION is a numeric category for the geographic region
of an office. The second INPUT statement uses an array  reference in the 
@<B>character-expression</B> pointer control to determine the location
POPULATION in the input records. The expression also uses the TRIM function
to trim trailing blanks from the character value. This way an exact match
is found between the character string in the input data and the value of the
array element.
<P>The following output that PROC PRINT generates shows
the resulting data set OFFICE2.




<P>
<B><I>Data Set Office2</I></B><BR>



<TABLE border="1" cellpadding="12" cellspacing="0" bgcolor="#FAFAFA">
<TR>
<TD><PRE>                         The SAS System                        1

           OBS    City         Location    Population

            1     New York         1            14   
            2     Cary             1          2274   
            3     Chicago          1            37   
            4     Vancouver        2             6   
            5     Milano           4           123   </PRE></TD></TR></TABLE>

<P>
<BR><H3> <A name="z0146305">Example 7: Moving the Pointer Backward</A> </H3>


<P>This example shows several ways to move the pointer backward.

<P>
<UL>

<LI>This INPUT statement uses the @ pointer control
to read a value for BOOK starting at column 26. Then the pointer moves back
to column 1 on the same line to read a value for COMPANY:  
<P>
<PRE>input @26 book $ @1 company;</PRE><P>

<LI>These INPUT statements use +<B>numeric-variable</B> or +(<B>expression</B>) to move the pointer backward one column.
These two sets of statements are equivalent.
<P>
<UL>

<LI>
<PRE>m=-1;
input x 1-10 +m y 2.;</PRE><P>

<LI>
<PRE>input x 1-10 +(-1) y 2.;</PRE><P>
</UL>
<P>
</UL>

<TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><FONT size="5"><A name="z0207343">See Also</A></FONT>
</FONT></B></TD></TR></TABLE>
<TABLE cellpadding="6" cellspacing="2">
<TR valign="top"><TD></TD><TD>Statements:
<P>
<TABLE cellpadding="6" cellspacing="2">
<TR valign="top"><TD></TD><TD><A href="z0201956.htm">ARRAY</A></TD></TR>
<TR valign="top"><TD></TD><TD><A href="z0148066.htm">INPUT, Column</A></TD></TR>
<TR valign="top"><TD></TD><TD><A href="z0148073.htm">INPUT, Formatted</A></TD></TR>
<TR valign="top"><TD></TD><TD><A href="z0144370.htm">INPUT, List</A></TD></TR>
<TR valign="top"><TD></TD><TD><A href="z0148147.htm">INPUT, Named</A></TD></TR></TABLE></TD></TR></TABLE>

<P><!-- navigation -->
<P><TABLE cellpadding="0" cellspacing="0">
<TR valign="top">
<TD align="center">
<A href="z0293668.htm">
<IMG border="0" SRC="../common/images/cont1.gif"><BR><FONT size="-2">Chapter Contents</FONT></A></TD>
<TD align="center">
<A href="z0178244.htm">
<IMG border="0" src="../common/images/prev1.gif"><BR><FONT size="-2">Previous</FONT></A></TD>
<TD align="center">
<A href="z0148066.htm">
<IMG border="0" SRC="../common/images/next1.gif"><BR><FONT size="-2">Next</FONT></A></TD>
<TD align="center">
<A href="#z0146292">
<IMG border="0" SRC="../common/images/top1.gif"><BR><FONT size="-2">Top of Page</FONT></A></TD>
</TR></TABLE>
<P><FONT size=1><A href="../common/images/copyrite.htm">Copyright 1999 by SAS Institute Inc., Cary, NC, USA. All rights reserved.</A></FONT>
</BODY>
</HTML>