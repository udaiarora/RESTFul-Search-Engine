<HTML>
<!-- This page produced Mon Jul 19 13:58:41 EDT 1999
 -->
<!-- Used program version 1.118.1.2 from beta -->
<HEAD>
<!-- <META http-equiv="Content-Type" content="text/html; charset="> -->
<TITLE>Statements : INFILE </TITLE></HEAD>
<BODY bgcolor="#FFFFFF">
<!-- navigation -->
<TABLE cellpadding="0" cellspacing="0">
<TR valign="top">
<TD align="center">
<A href="z0293668.htm">
<IMG border="0" SRC="../common/images/cont1.gif"><BR><FONT size="-2">Chapter Contents</FONT></A></TD>
<TD align="center">
<A href="z0214504.htm">
<IMG border="0" src="../common/images/prev1.gif"><BR><FONT size="-2">Previous</FONT></A></TD>
<TD align="center">
<A href="z0178244.htm">
<IMG border="0" SRC="../common/images/next1.gif"><BR><FONT size="-2">Next</FONT></A></TD>
</TR></TABLE>
<!-- running head -->
<TABLE width="100%" cellpadding="4">
<TR valign="MIDDLE">
<TD bgcolor="#CCCC99"><I><FONT size="2">INFILE</FONT></I></TD>
</TR>
</TABLE><H1><FONT size="5"><A name="z0146932">INFILE</A></FONT></H1>

<P><HR><BR><B>Identifies an external file to read with an INPUT statement</B><p>

<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="right" bgcolor="#F5F5F5" nowrap><B>Valid:</B></TD>
<TD bgcolor="#CCCCCC" align="left">in a DATA Step
</TD></TR>
<TR valign="top">
<TD align="right" bgcolor="#F5F5F5" nowrap><B>Category:</B></TD>
<TD bgcolor="#CCCCCC" align="left">File-handling
</TD></TR>
<TR valign="top">
<TD align="right" bgcolor="#F5F5F5" nowrap><B>Type:</B></TD>
<TD bgcolor="#CCCCCC" align="left">Executable
</TD></TR>
</TABLE><HR>
<TABLE cellspacing="0" cellpadding="1">
<TR>
<TD colspan="2"><A href="z0146932.htm#zid-2381"><FONT size="2"><B>Syntax</b></FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0146932.htm#z0165822"><FONT size="2"><B>Arguments</b></FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146932.htm#z0209366"><FONT size="2">Options</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146932.htm#z0209367"><FONT size="2">Host Options</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146932.htm#z0179039"><FONT size="2">DBMS-Specifications</FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0146932.htm#z0209368"><FONT size="2"><B>Details</b></FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146932.htm#z0209369"><FONT size="2">How to Use the INFILE Statement</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146932.htm#z0209370"><FONT size="2">Reading Multiple Input Files</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146932.htm#z0178009"><FONT size="2">Updating External Files in Place</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146932.htm#z1017828"><FONT size="2">Accessing the Contents of the Input Buffer</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146932.htm#z0165927"><FONT size="2">Reading Delimited Data</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146932.htm#z0167150"><FONT size="2">Reading Past the End of a Line</FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0146932.htm#z0209371"><FONT size="2"><B>Comparisons</b></FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0146932.htm#z0209372"><FONT size="2"><B>Examples</b></FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146932.htm#z0177189"><FONT size="2">Example 1: Changing How Delimiters are Treated</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146932.htm#z0177228"><FONT size="2">Example 2: Handling Missing Values and Short Records with List Input</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146932.htm#z0178012"><FONT size="2">Example 3:  Reading Files That Contain Variable-Length Records</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146932.htm#z0177201"><FONT size="2">Example 4: Reading from Multiple Input Files</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146932.htm#z0177247"><FONT size="2">Example 5: Updating an External File</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146932.htm#z0177221"><FONT size="2">Example 6: Truncating Copied Records</FONT></A></TD></TR>
<TR>
<TD width="18"></TD>
<TD><A href="z0146932.htm#z0177196"><FONT size="2">Example 7: Listing the Pointer Location</FONT></A></TD></TR>
<TR>
<TD colspan="2"><A href="z0146932.htm#z0209373"><FONT size="2"><B>See Also</b></FONT></A></TD></TR></TABLE>
<TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><H2><A name="zid-2381">Syntax</A></H2></TD></TR></TABLE>

<TABLE cellpadding="4" cellspacing="2">
<TR valign="top"><TD>
<B>INFILE</B>  <I>file-specification</I> 
&lt;<I>options</I>&gt; &lt;<I>host-options</I>&gt;;
</TD></TR></TABLE>
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top"><TD>
<B>INFILE</B>
<I>DBMS-specifications<I>;</I></I>
</TD></TR></TABLE><A name="zid-2382">&#13;</A>
<P><A name="z0853486">&#13;</A>
<P><TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><A name="z0165822">Arguments</A></FONT></B></TD></TR></TABLE>

<DL>
<DT><I><B>file-specification</B></I></DT>
<DD>identifies the source of the input data
records, which is an external file or in-stream data. <I>File-specification</I> can have these forms:

<P>
<DL>
<DT>'<I><B>external-file</B></I>'</DT>
<DD>specifies the physical name of an external
file. The physical name is the name that the operating environment uses to
access the file.<P></DD>

<DT><I><B>fileref</B></I></DT>
<DD>specifies the fileref of an external file.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Requirement:</B></TD>
<TD align="left" bgcolor="#F5F5F5">You must have previously
associated the fileref with an external file in a FILENAME statement, FILENAME
function, or an appropriate operating environment command.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="z0211297.htm">FILENAME</A>  </TD>
</TABLE>
<P></DD>

<DT><I><B>fileref</B>(<B>file</B>)</I></DT>
<DD>specifies a  fileref of an aggregate storage
location and the name of a file or member, enclosed in parentheses, that resides
in that
location.
<P><B>Operating Environment Information:</B>&nbsp;&nbsp;&nbsp;Different
operating environments call
an aggregate grouping of files by different names, such as a directory, a
MACLIB, or a partitioned data set. For details on how to specify external
files, see the SAS documentation for your operating environment.&nbsp;&nbsp;<img border="0" src="../common/images/cautend.gif" alt="[cautionend]" align="bottom">
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Requirement:</B></TD>
<TD align="left" bgcolor="#F5F5F5">You must have previously
associated the fileref with an external file in a FILENAME statement, a FILENAME
function, or an appropriate operating environment command.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="z0211297.htm">FILENAME</A>  </TD>
</TABLE>
<P></DD>

<DT>CARDS  |  CARDS4</DT>
<DD>for a definition, see <A href="#z0146931">DATALINES </A>.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Alias:</B></TD>
<TD align="left" bgcolor="#F5F5F5">DATALINES  |  DATALINES4</TD>
</TABLE>
<P></DD>

<DT><A name="z0146931">&#13;</A>DATALINES  | 
DATALINES4</DT>
<DD>specifies that the input data immediately
follows the DATALINES or DATALINES4 statement in the DATA step. This allows
you to use the INFILE statement options to control how the INPUT statement
reads instream data lines.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Alias:</B></TD>
<TD align="left" bgcolor="#F5F5F5">CARDS  |  CARDS4</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0177189">Changing How Delimiters are Treated</A></TD>
</TABLE>
<P></DD>
</DL>
<P></DD>
</DL>

<BR><H3><A name="z0209366">Options</A></H3>


<P>
<DL>
<DT><A name="z0853507">&#13;BLKSIZE=<I><B>block-size</B></I></A></DT>
<DD>specifies the block size of the input file. 
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Default:</B></TD>
<TD align="left" bgcolor="#F5F5F5">dependent on the operating
environment
<P><B>Operating Environment Information:</B>&nbsp;&nbsp;&nbsp;For
details, see the SAS documentation
for your operating environment.&nbsp;&nbsp;<img border="0" src="../common/images/cautend.gif" alt="[cautionend]" align="bottom"></TD>
</TABLE>
<P></DD>
<A NAME="z0167030"></A>
<DT><A name="z0853511">&#13;COLUMN=<I><B>variable</B></I></A></DT>
<DD>names a variable that SAS uses to assign
the current column location of the input pointer. Like automatic variables,
the COLUMN= variable is not written to the data set.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Alias:</B></TD>
<TD align="left" bgcolor="#F5F5F5">COL=</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See Also:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0166943">LINE=</A></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0177196">Listing the Pointer Location</A></TD>
</TABLE>
<P></DD>
<A NAME="z0166841"></A>
<DT><A name="z0853516">&#13;DELIMITER=<I><B>delimiter(s)</B></I></A></DT>
<DD>specifies a delimiter for list input, where <I>delimiter</I>
is
<P>
<DL>
<DT>'<I><B>list-of-delimiting-characters</B></I>'</DT>
<DD>specifies one or more characters to read
as delimiters. 
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Requirement:</B></TD>
<TD align="left" bgcolor="#F5F5F5">Enclose the list
of characters in quotation marks.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0177189">Changing How Delimiters are Treated</A></TD>
</TABLE>
<P></DD>

<DT><I><B>character-variable</B></I></DT>
<DD>specifies a character variable whose value
becomes the delimiter.<P></DD>
</DL>

<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Alias:</B></TD>
<TD align="left" bgcolor="#F5F5F5">DLM=</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Default:</B></TD>
<TD align="left" bgcolor="#F5F5F5">blank space</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">DELIMITER=  allows you to
use list input even when the data are separated by characters other than spaces.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0165927">Reading Delimited Data</A></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See Also:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0165937">DSD option</A></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0177189">Changing How Delimiters are Treated</A></TD>
</TABLE>
<P></DD>
<A NAME="z0165937"></A>
<DT><A name="z0853530">&#13;DSD</A></DT>
<DD>changes how SAS treats delimiters when list
input is used and sets the default delimiter to a comma. When you specify
DSD, SAS treats two consecutive delimiters as a missing value and removes
quotation marks from character values.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Interaction:</B></TD>
<TD align="left" bgcolor="#F5F5F5"> Use the DELIMITER=
option to change the delimiter.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">Use the DSD option and list
input to read a character value that contains a delimiter within a quoted
string. The INPUT statement treats the delimiter as a valid character and
removes the quotation marks from the character string before the value is
stored. Use the tilde (~) format modifier to retain the quotation marks.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0165927">Reading Delimited Data</A></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See Also:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0166841">DELIMITER=</A></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0177228">Handling Missing Values and Short Records with List Input</A>
and     
<A href="#z0177189">Changing How Delimiters are Treated</A></TD>
</TABLE>
<P></DD>
<A NAME="z0166931"></A>
<DT><A name="z0853537">&#13;END=<I><B>variable</B></I></A></DT>
<DD>names  a variable that SAS sets to 1 when
the current input data record is the last in the input file.  Until SAS processes
the last data record, the END= variable is set to 0. Like automatic variables,
this variable is not written to the data set.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Restriction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">You cannot use the
END= option with 
<P>
<UL>

<LI>the UNBUFFERED option<P>

<LI>the DATALINES or DATALINES4
statement<P>

<LI>an INPUT statement that reads multiple input data
records.<P>
</UL>
</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">Use the option <A href="#z0166894">EOF=</A> when END= is invalid.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0177201">Reading from Multiple Input Files</A></TD>
</TABLE>
<P></DD>

<DT><A name="z0853545">&#13;</A><A NAME="z0166894"></A>EOF=<I><B>label</B></I></DT>
<DD>specifies a statement label that is the
object of an implicit GO TO when the INFILE statement reaches end-of-file.
When an INPUT statement attempts to read from a file that has no more records,
SAS moves execution to the statement label indicated.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Interaction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">Use EOF= instead
of the END= option with
<P>
<UL>

<LI>the UNBUFFERED option<P>

<LI>the DATALINES or DATALINES4
statement<P>

<LI>an INPUT statement that reads multiple input data
records.<P>
</UL>
</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">The EOF= option is useful
when you read from multiple input files sequentially.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See Also:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0166931">END=</A>,
<A href="#z0166933">EOV=</A>, and
<A href="#z0166935">UNBUFFERED</A></TD>
</TABLE>
<P></DD>
<A NAME="z0166933"></A>
<DT><A name="z0853553">&#13;EOV=<I><B>variable</B></I></A></DT>
<DD>names a variable that SAS sets to 1 when
the first record in a file in a series of concatenated files is read. The
variable is set only after SAS encounters the next file. Like automatic variables,
the EOV= variable is not written to the data set.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">Reset the EOV= variable
back to 0 after SAS encounters each boundary.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See Also:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0166931">END=</A> and
<A href="#z0166894">EOF=</A></TD>
</TABLE>
<P></DD>

<DT><A name="z0853557">&#13;EXPANDTABS | NOEXPANDTABS</A></DT>
<DD>specifies whether to expand tab characters
to the standard tab setting, which is set at 8-column intervals that start
at column 9.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Default:</B></TD>
<TD align="left" bgcolor="#F5F5F5">NOEXPANDTABS</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">EXPANDTABS is useful when
you read data that contain the tab character that is native to your operating
environment.</TD>
</TABLE>
<P></DD>

<DT><A name="z0853561">&#13;FILENAME=<I><B>variable</B></I></A></DT>
<DD>names a variable that SAS sets to the physical
name of the currently opened input file. Like automatic variables, the FILENAME=
variable is not written to the data set.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">Use a <A href="z0218807.htm">LENGTH statement</A>
to make the variable length  long enough to contain the value of the filename.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See Also:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0166950">FILEVAR=</A></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0177201">Reading from Multiple Input Files</A></TD>
</TABLE>
<P></DD>
<A NAME="z0166950"></A>
<DT><A name="z0853566">&#13;FILEVAR=<I><B>variable</B></I></A></DT>
<DD>names a variable whose change in value causes
the INFILE statement to close the current input file and open a new one. When
the next INPUT statement executes, it reads from the new file that the FILEVAR=
variable specifies. Like automatic variables, this variable is not written
to the data set.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Restriction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">The FILEVAR= variable
must contain a character string that is a physical filename. </TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Interaction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">When you use the
FILEVAR= option, the <I>file-specification</I> is just
a placeholder, not an actual filename or a fileref that has been previously-assigned
to a file. SAS uses this placeholder for reporting processing information
to the SAS log. It must conform to the same rules as a fileref.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">Use FILEVAR=  to dynamically
change the currently opened input file to a new physical file.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See Also:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0178009">Updating External Files in Place</A></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0177201">Reading from Multiple Input Files</A></TD>
</TABLE>
<P></DD>
<A NAME="z0167125"></A>
<DT><A name="z0853572">&#13;FIRSTOBS=<I><B>record-number</B></I></A></DT>
<DD>specifies a record number that SAS uses
to begin reading input data records in the input file.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Default:</B></TD>
<TD align="left" bgcolor="#F5F5F5">1</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">Use FIRSTOBS= with <A href="#z0167127">OBS=</A> to
read a range of records from the middle of a file. </TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Example:</B></TD>
<TD align="left" bgcolor="#F5F5F5">This statement processes
record 50 through record 100:



<PRE>infile <I>file-specification</I> firstobs=50 obs=100;</PRE> </TD>
</TABLE>
<P></DD>
<A NAME="z0167074"></A>
<DT><A name="z0853577">&#13;FLOWOVER</A></DT>
<DD>causes an INPUT statement to continue to
read the next input data record if it does not find values in the current
input line for all the variables in the statement. This is the default behavior
of the INPUT statement.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0167150">Reading Past the End of a Line</A></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See Also:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0166987">MISSOVER</A>,
<A href="#z0166995">STOPOVER</A>, and
<A href="#z0166997">TRUNCOVER</A></TD>
</TABLE>
<P></DD>

<DT><A name="z0853581">&#13;LENGTH=<I><B>variable</B></I></A></DT>
<DD>names a variable that SAS sets to the length
of the current input line.  SAS does not assign the variable a value until
an INPUT statement executes. Like automatic variables, the LENGTH= variable
is not written to the data set.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">This option in conjunction
with the <A href="z0193602.htm#z0316294">$VARYING informat</A> is useful when the field width varies.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0178012">Reading Files That Contain Variable-Length Records</A> and
<A href="#z0177221">Truncating Copied Records</A></TD>
</TABLE>
<P></DD>
<A NAME="z0166943"></A>
<DT><A name="z0853585">&#13;LINE=<I><B>variable</B></I></A></DT>
<DD>names a variable that SAS sets to the line
location of the input pointer in the input buffer. Like automatic variables,
the LINE= variable is not written to the data set.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Range:</B></TD>
<TD align="left" bgcolor="#F5F5F5">1 to the value of the
N= option</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Interaction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">The value of the
LINE= variable is the current relative line number within the group of lines
that is specified by the N= option or by the #<I>n</I>
line pointer control in the INPUT statement.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See Also:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0167030">COLUMN=</A> and
<A href="#z0167032">N=</A></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0177196">Listing the Pointer Location</A></TD>
</TABLE>
<P></DD>

<DT><A name="z0853591">&#13;LINESIZE=<I><B>line-size</B></I></A></DT>
<DD>specifies the record length that is available
to the INPUT
statement.
<P><B>Operating Environment Information:</B>&nbsp;&nbsp;&nbsp;Values
for <I>line-size</I> are dependent on the operating environment record
size. For details, see the SAS documentation for your operating environment.&nbsp;&nbsp;<img border="0" src="../common/images/cautend.gif" alt="[cautionend]" align="bottom"> 
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Alias:</B></TD>
<TD align="left" bgcolor="#F5F5F5">LS= </TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Range:</B></TD>
<TD align="left" bgcolor="#F5F5F5">up to 32767</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Interaction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">If an INPUT statement
attempts to read past the column that is specified by the LINESIZE= option,
the action that is taken depends on whether the FLOWOVER, MISSOVER, SCANOVER,
STOPOVER, or TRUNCOVER option is in effect. <A href="#z0167074">FLOWOVER</A>  is the default.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">Use LINESIZE= to limit the
record length when you do not want to read the entire record.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Example:</B></TD>
<TD align="left" bgcolor="#F5F5F5">If your data lines contain
a sequence number in columns 73 through 80, use this INFILE statement to restrict
the INPUT statement to the first 72 columns:



<PRE>infile <I>file-specification</I> linesize=72;</PRE></TD>
</TABLE>
<P></DD>
<A NAME="z0167132"></A>
<DT><A name="z0853599">&#13;LRECL=<I><B>logical-record-length</B></I></A></DT>
<DD>specifies the logical record
length.
<P><B>Operating Environment Information:</B>&nbsp;&nbsp;&nbsp;Values
for <I>logical-record-length</I>
are dependent on the operating environment. For details, see the SAS documentation
for your operating environment.&nbsp;&nbsp;<img border="0" src="../common/images/cautend.gif" alt="[cautionend]" align="bottom">
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Default:</B></TD>
<TD align="left" bgcolor="#F5F5F5">dependent on the operating
environment's file characteristics.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">LRECL= specifies the physical
line length of the file. LINESIZE= tells the INPUT statement how much of the
line to read.</TD>
</TABLE>
<P></DD>
<A NAME="z0166987"></A>
<DT><A name="z0853604">&#13;MISSOVER</A></DT>
<DD>prevents an INPUT statement from reading
a new input data record if it does not find values in the current input line
for all the variables in the statement. When an INPUT statement reaches the
end of the current input data record, variables without any values assigned
are set to missing.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">Use MISSOVER if the last
field(s) may be missing and you want SAS to assign missing values to the corresponding
variable.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0167150">Reading Past the End of a Line</A></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See Also:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0167074">FLOWOVER</A>,
<A href="#z0241697">SCANOVER</A>, <A href="#z0166995">STOPOVER</A>, and
<A href="#z0166997">TRUNCOVER</A></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0177228">Handling Missing Values and Short Records with List Input</A></TD>
</TABLE>
<P></DD>

<DT><A NAME="z0167032"></A>N=<I><B>available-lines</B></I></DT>
<DD>specifies the number of lines that are available
to the input pointer at one time.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Default:</B></TD>
<TD align="left" bgcolor="#F5F5F5">the highest value following
a # pointer control in any INPUT statement in the DATA step.  If you omit
a # pointer control, the default value is 1.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Interaction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">This option affects
only the number of lines that the pointer can access at a time; it has no
effect on the number of lines an INPUT statement reads.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">When you use # pointer controls
in an INPUT statement that are less than the value of N=, you might get unexpected
results. To prevent this, include a # pointer control that equals the value
of the N= option. For example, 



<PRE>infile '<I>external
file</I>' n=5;
input #2 name : $25. #3 job : $25. #5;</PRE>


The INPUT statement includes
a #5 pointer control, even though no data are read from that record.   
 </TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0177196">Listing the Pointer Location</A></TD>
</TABLE>
<P></DD>

<DT><A NAME="z0224882"></A><A name="z0853616">&#13;NBYTE=<I><B>variable</B></I></A></DT>
<DD>specifies the name of a variable that contains
the number of bytes to read from a file when you are reading data in stream
record format (RECFM=S in the FILENAME statement).
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Default:</B></TD>
<TD align="left" bgcolor="#F5F5F5">the LRECL value of the
file</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Interaction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">If the number of
bytes to read is set to -1, the FTP and SOCKET access methods return the number
of bytes that are currently available in the input buffer.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See:</B></TD>
<TD align="left" bgcolor="#F5F5F5">the FILENAME, SOCKET <A href="z0218957.htm#z0229829">RECFM= option</A> and the FILENAME, FTP
<A href="z0178980.htm#z0229899">RECFM=
option</A></TD>
</TABLE>
<P></DD>
<A NAME="z0167127"></A>
<DT><A name="z0853621">&#13;OBS=<I><B>record-number</B></I></A></DT>
<DD>specifies the record number of the last
record to read in an input file that is read sequentially.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">Use OBS= with  <A href="#z0167125">FIRSTOBS=</A>
to read a range of records from the middle of a file.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Example:</B></TD>
<TD align="left" bgcolor="#F5F5F5">This statement processes
only the first 100 records in the file:



<PRE>infile <I>file-specification</I> obs=100;</PRE></TD>
</TABLE>
<P></DD>
<A NAME="z0210780"></A>
<DT><A name="z0853625">&#13;PAD | NOPAD</A></DT>
<DD>controls whether SAS pads the records that
are read from an external file with blanks to the length that is specified
in the LRECL= option.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Default:</B></TD>
<TD align="left" bgcolor="#F5F5F5">NOPAD</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See
Also:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0167132">LRECL=</A></TD>
</TABLE>
<P></DD>

<DT><A name="z0853629">&#13;PRINT | NOPRINT</A></DT>
<DD>specifies whether the input file contains
carriage control characters.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">To read a print file in
a DATA step without having to remove the carriage control characters, specify
PRINT. To read the carriage control characters as data values, specify NOPRINT.</TD>
</TABLE>
<P></DD>

<DT><A name="z0853632">&#13;RECFM=<I><B>record-format</B></I></A></DT>
<DD>specifies the record format of the input
file. 
<P><B>Operating Environment Information:</B>&nbsp;&nbsp;&nbsp; Values
for <B>record-format</B> are dependent
on the operating environment. For details, see the SAS documentation for your
operating environment.&nbsp;&nbsp;<img border="0" src="../common/images/cautend.gif" alt="[cautionend]" align="bottom"><P></DD>
<A NAME="z0241697"></A>
<DT><A name="z0853635">&#13;SCANOVER</A></DT>
<DD>causes the INPUT statement to scan the input
data records until the character string that is specified in the @'<I>character-string</I>' expression is
found.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Interaction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">The MISSOVER, TRUNCOVER,
and STOPOVER options change how the INPUT statement behaves when it  scans
for the @'<I>character-string</I>' expression and reaches
the end of record. By default (FLOWOVER option), the INPUT statement scans
the next record while these other options cause scanning to stop.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5"> It is redundant to specify
both SCANOVER and FLOWOVER.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0167150">Reading Past the End of a Line</A></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See Also:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0167074">FLOWOVER</A>,
<A href="#z0166987">MISSOVER</A>, <A href="#z0166995">STOPOVER</A>, and
<A href="#z0166997">TRUNCOVER</A></TD>
</TABLE>
<P></DD>
<A NAME="z0242686"></A>
<DT><A name="z0853641">&#13;SHAREBUFFERS</A></DT>
<DD>specifies that the FILE statement and the
INFILE statement share the same buffer.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Alias:</B></TD>
<TD align="left" bgcolor="#F5F5F5">SHAREBUFS</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5"> Use SHAREBUFFERS with the
INFILE, FILE, and PUT statements to update an external file in place. This
saves CPU time because the PUT statement output is written straight from the
input buffer instead of the output buffer.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">Use SHAREBUFFERS to update
specific fields in an external file instead of an entire record.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0177247">Updating an External File</A></TD>
</TABLE>
<P></DD>

<DT><A name="z0853647">&#13;START=<I><B>variable</B></I></A></DT>
<DD>names a variable whose value SAS uses as
the first column number of the record that the PUT _INFILE_ statement writes.
Like automatic variables, the START variable is not written to the data set. 
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See Also:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="z0161869.htm#z0177250">_INFILE_ option</A> in the
PUT statement</TD>
</TABLE>
<P></DD>
<A NAME="z0166995"></A>
<DT><A name="z0853650">&#13;STOPOVER</A></DT>
<DD>causes the DATA step to stop processing
if an INPUT statement reaches the end of the current record without finding
values for all variables in the statement. When an input line does not contain
the expected number of values, SAS sets _ERROR_ to 1, stops building the data
set as though a STOP statement has executed, and prints the incomplete data
line.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">Use FLOWOVER to reset the
default behavior.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0167150">Reading Past the End of a Line</A></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See Also:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0167074">FLOWOVER</A>,
<A href="#z0166987">MISSOVER</A>, <A href="#z0241697">SCANOVER</A>, and
<A href="#z0166997">TRUNCOVER</A></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Featured
in:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0177228">Handling Missing Values and Short Records with List Input</A></TD>
</TABLE>
<P></DD>
<A NAME="z0166997"></A>
<DT><A name="z0853656">&#13;TRUNCOVER</A></DT>
<DD>overrides the default behavior of the INPUT
statement when an input data record is shorter than the INPUT statement expects.
By default, the INPUT statement automatically reads the next input data record.
TRUNCOVER enables you to read variable-length records when some records are
shorter than the INPUT statement expects. Variables without any values assigned
are set to missing.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">Use TRUNCOVER to assign
the contents of the input buffer to a variable when the field is shorter than
expected.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0167150">Reading Past the End of a Line</A></TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>See Also:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z0167074">FLOWOVER</A>,
<A href="#z0166987">MISSOVER</A>, <A href="#z0241697">SCANOVER</A>, and
<A href="#z0166995">STOPOVER</A></TD>
</TABLE>
<P></DD>
<A NAME="z0166935"></A>
<DT><A name="z0853660">&#13;UNBUFFERED</A></DT>
<DD>tells SAS not to perform a buffered ("look
ahead") read.
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Alias:</B></TD>
<TD align="left" bgcolor="#F5F5F5">UNBUF</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Interaction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">When you use UNBUFFERED,
SAS never sets the END= variable to 1.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">When you read in-stream
data with a DATALINES statement, UNBUFFERED is in effect.</TD>
</TABLE>
<P></DD>

<DT><A name="z0853665">&#13;_INFILE_=<I><B>variable</B></I></A></DT>
<DD>names a character variable that references
the contents of the current input buffer for this INFILE statement. You can
use the variable in the same way as any other variable, even as the target
of an assignment. The variable is automatically retained and initialized to
blanks.  Like automatic variables, the _INFILE_= variable is not written to
the data set. 
<TABLE cellpadding="4" cellspacing="2">
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Restriction:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><I>variable </I> cannot be a previously defined variable. Make sure that the
_INFILE_= specification is the first occurence of this variable in the DATA
step. Do not set or change the length of _INFILE_= variable with the LENGTH
or ATTRIB statements. However, you can attach a format to this variable with
the ATTRIB or FORMAT statement.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Interaction:</B></TD>
<TD align="left" bgcolor="#F5F5F5">The maximum length
of this character variable is the logical record length (<A href="#z0167132">LRECL=</A>)  for the specified INFILE statement. However, SAS
does not open the file to know the LRECL= until prior to the execution phase.
Therefore, the designated size for this variable during the compilation phase
is 32,767.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">Modification of this variable
directly modifies the INFILE statement's current input buffer. Any PUT _INFILE_
(when this INFILE is current) that follows the buffer modification reflects
the modified buffer contents. The _INFILE_= variable accesses only the current
input buffer of the specified INFILE statement even if you use the N= option
to specify multiple buffers.</TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Tip:</B></TD>
<TD align="left" bgcolor="#F5F5F5">To access the contents of
the input buffer in another statement without using the _INFILE_= option,
use the automatic variable _INFILE_. </TD>
<TR valign="top">
<TD align="left" bgcolor="#F5F5F5" width="95" nowrap><B>Main
Discussion:</B></TD>
<TD align="left" bgcolor="#F5F5F5"><A href="#z1017828">Accessing the Contents of the Input Buffer</A></TD>
</TABLE>
<P></DD>
</DL>

<BR><H3><A name="z0209367">Host Options</A></H3>


<P>
<P><B>Operating Environment Information:</B>&nbsp;&nbsp;&nbsp;For
descriptions of operating environment-specific options
in the INFILE statement, see the SAS documentation for your operating environment.&nbsp;&nbsp;<img border="0" src="../common/images/cautend.gif" alt="[cautionend]" align="bottom">
<BR><H3><A name="z0179039">DBMS-Specifications</A></H3>


<DL>
<DT><I><B>DBMS-Specifications</B></I></DT>
<DD>enable you to read records from some DBMS
files. You must license SAS/ACCESS software to be able to read from DBMS files.
See the SAS/ACCESS documentation for the DBMS that you use.<P></DD>
</DL>


<P><TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><A name="z0209368">Details</A></FONT></B></TD></TR></TABLE>

<P>
<P><B>Operating Environment Information:</B>&nbsp;&nbsp;&nbsp;The
INFILE statement contains operating environment-specific material.  See
the SAS documentation for your operating environment before using this statement.&nbsp;&nbsp;<img border="0" src="../common/images/cautend.gif" alt="[cautionend]" align="bottom">
<BR><H3><A name="z0209369">How to Use the INFILE Statement</A></H3>


<P>Because the INFILE statement identifies the file to read, it must execute
before the INPUT statement that reads the input data records. You can use
the INFILE statement in conditional processing, such as an IF-THEN statement,
because it is executable. This allows you to control the source of the input
data records.
<P>Usually, you use an INFILE statement to read data from
an external file. When data are read from the job stream, you must use a DATALINES
statement. However, to take advantage of certain data-reading options that
are available only in the INFILE statement, you can use an INFILE statement
with the file-specification DATALINES and a DATALINES statement in the same
DATA step.
<P>When you use more than one INFILE statement for the
same file-specification and you use options in each INFILE statement, the
effect is additive.  To avoid confusion, use all the options in the first
INFILE statement for a given external file.
<BR><H3><A name="z0209370">Reading Multiple Input Files</A></H3>


<P><A name="z0853684">&#13;You
can read from multiple input files in a single iteration of the DATA step
in one of two ways:</A>
<P>
<UL>

<LI>to keep multiple files open and change which file
is read, use multiple INFILE statements.<P>

<LI>To dynamically change the current input file within
a single DATA step, use the FILEVAR= option in an INFILE statement. The FILEVAR=
option enables you to read from one file, close it, and then open another.
See <A href="#z0177201">Reading from Multiple Input Files</A>. <P>
</UL>
.
<BR><H3><A name="z0178009">Updating External Files in Place</A></H3>


<P><A name="z0853687">&#13;You
can use the INFILE statement in combination with the FILE statement to update
records in an external file. Follow these steps: </A>
<OL START="1" type="1">
<LI>Specify the INFILE statement before the FILE statement.<P>

<LI>Specify the
same fileref or physical filename
in each statement.<P>

<LI>Use options that are common to both the INFILE
and FILE statements in the INFILE statement instead of the FILE statement.
(Any such options that are used in the FILE statement are ignored.)<P>
</OL>
 See <A href="#z0177247">Updating an External File</A>.
<P>To
update individual fields within a record instead
of the entire record, see <A href="#z0242686">SHAREBUFFERS</A>.
<BR><H3><A name="z1017828">Accessing the Contents of the Input Buffer</A></H3>


<P>In addition to the _INFILE_= variable, you can use the automatic
_INFILE_ variable to reference the contents of the current input buffer for
the most recent execution of the INFILE statement. This character variable
is automatically retained and initialized to blanks. Like other automatic
variable, _INFILE_ is not written to the data set.
<P>When you specify the _INFILE_= option in a INFILE statement
then this variable is also indirectly referenced by the automatic  _INFILE_
  variable. If the automatic _INFILE_ variable is present and you omit _INFILE_=
in a particular INFILE statement, then SAS creates an internal _INFILE_= variable
for that INFILE statement. Otherwise, SAS does not create  the _INFILE_= variable
for a particular FILE. 
<P>During execution and at the point of reference, the
maximum length of this character variable is the maximum length of the current
_INFILE_= variable.  However, because _INFILE_ merely references other variables
whose lengths are not known until prior to the execution phase, the designated
length is 32,767 during the compilation phase. For example, if you assign
_INFILE_ to a new variable whose length is undefined, the  default length
of the new variable is 32,767. You can not use the LENGTH statement and the
ATTRIB statement to set or override the length of _INFILE_. You can use the
FORMAT statement and the ATTRIB statement to assign a format to _INFILE_.
<P>Like other SAS variables, you can update the _INFILE_
variable in an assignment statement. You can also use a format with _INFILE_
in a PUT statement. For example 



<PRE>put _infile_ $hex100.;</PRE>outputs the contents of the input buffer using  a hexadecimal format. 
<P>Any modification of the _INFILE_ directly modifies the
current input buffer for the current INFILE statement.  The execution of any
PUT _INFILE_ statement that follows this buffer modification will reflect
the contents of the modified buffer.
<P>_INFILE_ only accesses the contents of the current input
buffer for a INFILE statement, even when you use the N= option to specify
multiple buffers. You can access all the N= buffers, but you must use a INPUT
statement with the # line pointer control to make the desired buffer the current
input buffer.
<BR><H3><A name="z0165927">Reading Delimited Data</A></H3>


<P><A name="z0853692">&#13;By
default, the delimiter to read input data records with list input is a blank
space. Both the DSD option and the DELIMITER= option affect how list input
handles delimiters. The DELIMITER= option specifies that the INPUT statement
use a character other than a blank as a delimiter for data values that are
read with list input. When the DSD option is in effect, the INPUT statement
uses a comma as the default delimiter.</A>
<P>To read a value as missing between two consecutive delimiters,
use the DSD option. By default, the INPUT statement treats consecutive delimiters
as a unit. When you use DSD, the INPUT statement treats consecutive delimiters
separately. Therefore, a value that is missing between consecutive delimiters
is read as a missing value. To change the delimiter from a comma to another
value, use the DELIMITER= option.
<P>For example, this DATA step program uses list input
to read data that are separated with commas. The second data line contains
a missing value.  Because SAS allows consecutive delimiters with list input,
the INPUT statement cannot detect the missing value.  



<PRE>data scores;
   infile datalines delimiter=',';
   input test1 test2 test3;
   datalines;
91,87,95
97,,92
,1,1
;</PRE>


With the FLOWOVER option in effect, the data set SCORES contains two,
not three, observations. The second observation is built incorrectly: 
<P>
<TABLE cellpadding="6" cellspacing="0" border="0">


<TR valign="bottom" bgcolor="#CCCCCC">
  <TH  colspan="2" align="LEFT" valign="BOTTOM" ><B>OBS </B></TH>
  <TH  align="LEFT" valign="BOTTOM" ><B>TEST1 </B></TH>
  <TH  align="LEFT" valign="BOTTOM" ><B>TEST2 </B></TH>
  <TH  align="LEFT" valign="BOTTOM" ><B>TEST3 </B></TH>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD  colspan="2" align="LEFT" valign="TOP">1  </TD>
  
<TD  align="LEFT" valign="TOP">91 </TD>
  
<TD  align="LEFT" valign="TOP">87  </TD>
  
<TD  align="LEFT" valign="TOP">95</TD>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD  colspan="2" align="LEFT" valign="TOP">2  </TD>
  
<TD  align="LEFT" valign="TOP">97 </TD>
  
<TD  align="LEFT" valign="TOP">92  </TD>
  
<TD  align="LEFT" valign="TOP">1</TD>
</TR>

</TABLE>

<BR>To correct the problem, use the DSD option in the INFILE
statement.
 






<PRE>   infile datalines dsd;</PRE>Now the INPUT
statement detects the two consecutive delimiters and therefore assigns a missing
value to variable TEST 2 in the second observation. 
<P>
<P>
<TABLE cellpadding="6" cellspacing="0" border="0">


<TR valign="bottom" bgcolor="#CCCCCC">
  <TH  colspan="2" align="LEFT" valign="BOTTOM" ><B>OBS </B></TH>
  <TH  align="LEFT" valign="BOTTOM" ><B>TEST1 </B></TH>
  <TH  align="LEFT" valign="BOTTOM" ><B>TEST2 </B></TH>
  <TH  align="LEFT" valign="BOTTOM" ><B>TEST3 </B></TH>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD  colspan="2" align="LEFT" valign="TOP">1  </TD>
  
<TD  align="LEFT" valign="TOP">91  </TD>
  
<TD  align="LEFT" valign="TOP">87  </TD>
  
<TD  align="LEFT" valign="TOP">95</TD>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD  colspan="2" align="LEFT" valign="TOP">2  </TD>
  
<TD  align="LEFT" valign="TOP">97  </TD>
  
<TD  align="LEFT" valign="TOP">.  </TD>
  
<TD  align="LEFT" valign="TOP">92</TD>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD  colspan="2" align="LEFT" valign="TOP">3  </TD>
  
<TD  align="LEFT" valign="TOP">1  </TD>
  
<TD  align="LEFT" valign="TOP">1  </TD>
  
<TD  align="LEFT" valign="TOP">1</TD>
</TR>

</TABLE>

<BR>The DSD option also enables list input to read a character
value that contains a delimiter within a quoted string. For example, if data
are separated with commas, DSD enables you to place the character string in
quotation marks and read a comma as a valid character. SAS does not store
the quotation marks as part of the character value. To retain the quotation
marks as part of the value, use the tilde (~) format modifier in an INPUT
statement. See <A href="#z0177189">Changing How Delimiters are Treated</A>.
<BR><H3><A name="z0167150">Reading Past the End of a Line</A></H3>


<P><A name="z0853724">&#13;By
default, if the INPUT statement tries to read past the end of the current
input data record, it moves the input pointer to column 1 of the next record
to read the remaining values. This default behavior is specified by the FLOWOVER
option. A message is written to the SAS log:  


</A>
<PRE>NOTE: SAS went to a new line when INPUT
@'CHARACTER_STRING' scanned past the end of a line.</PRE>


The STOPOVER option treats this condition as an
error and stops
building the data set. The MISSOVER option sets the remaining INPUT statement
variables to missing values. The SCANOVER option scans the input record until
it finds the specified <I>character-string</I>. The
FLOWOVER option restores the default behavior.
<P>The TRUNCOVER option, like the
MISSOVER option, overrides
the default behavior of the INPUT statement. The MISSOVER option, however,
causes the INPUT statement to set a value to missing if the statement is unable
to read an entire field because the field length specified in the INPUT statement
is too short. The TRUNCOVER option writes whatever characters are read to
the appropriate variable so that you know what the input data record contained.
<P>For example, an external file with variable-length records
contains these records: 



<PRE>----+----1----+----2
1
22
333
4444
55555</PRE>


The following DATA step reads these data to create a SAS data
set. Only one of the input records is as long as the informatted length of
the variable TESTNUM.  



<PRE>data numbers;
   infile '<I>external-file</I>';
   input testnum 5.;
run;</PRE>


This DATA step creates the three observations from the five input
records because by default the FLOWOVER option is used to read the input records.
<P>If you use the MISSOVER option in the INFILE statement,
the DATA step creates five observations. However, all the values that were
read from records that were too short are set to missing. Use the TRUNCOVER
option in the INFILE statement to correct this problem: 



<PRE>infile '<I>external-file</I>' truncover;</PRE>


The DATA step now reads the
same input records and creates five observations. See <A href="#z0171390">The Value of TESTNUM Using Different INFILE Statement Options</A> to compare the SAS data
sets.
<P>
<TABLE cellpadding="6" cellspacing="0" border="0">
<CAPTION align="top"><B><I><A name="z0171390">The Value of TESTNUM Using Different INFILE Statement Options</A></I></B></CAPTION>


<TR valign="bottom" bgcolor="#CCCCCC">
  <TH  align="LEFT" valign="BOTTOM" ><B><A name="z0171390">&#13;OBS </A></B></TH>
  <TH  align="LEFT" valign="BOTTOM" ><B>FLOWOVER</B></TH>
  <TH  align="LEFT" valign="BOTTOM" ><B>MISSOVER</B></TH>
  <TH  align="LEFT" valign="TOP" ><B>TRUNCOVER</B></TH>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD  align="LEFT" valign="TOP">1  </TD>
  
<TD  align="LEFT" valign="TOP">22</TD>
  
<TD  align="LEFT" valign="TOP">.</TD>
  
<TD  align="LEFT" valign="TOP">1</TD>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD  align="LEFT" valign="TOP">2  </TD>
  
<TD  align="LEFT" valign="TOP">4444</TD>
  
<TD  align="LEFT" valign="TOP">.</TD>
  
<TD  align="LEFT" valign="TOP">22</TD>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD  align="LEFT" valign="TOP">3  </TD>
  
<TD  align="LEFT" valign="TOP">55555</TD>
  
<TD  align="LEFT" valign="TOP">.</TD>
  
<TD  align="LEFT" valign="TOP">333</TD>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD  align="LEFT" valign="TOP">4  </TD>
  
<TD ><BR></TD>
  
<TD  align="LEFT" valign="TOP">.</TD>
  
<TD  align="LEFT" valign="TOP">4444</TD>
</TR>


<TR valign="top" bgcolor="#FFFFFF">
  
<TD  align="LEFT" valign="TOP">5  </TD>
  
<TD ><BR></TD>
  
<TD  align="LEFT" valign="TOP">55555</TD>
  
<TD  align="LEFT" valign="TOP">55555</TD>
</TR>

</TABLE>

<BR>
<P><TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><A name="z0209371">Comparisons</A></FONT></B></TD></TR></TABLE>

<P>
<P>
<UL>

<LI><A name="z0853756">&#13;The INFILE statement specifies
the <B>input file</B>  for any INPUT statements in the DATA step. The
FILE statement specifies the <B>output file</B>  for any PUT statements
in the DATA step.</A><P>

<LI>An INFILE statement usually identifies data from
an external file. A DATALINES statement indicates that data follow in the
job stream. You can use the INFILE statement with the file specification DATALINES
to take advantage of certain data-reading options that effect how the INPUT
statement reads in-stream data.<P>
</UL>

<P><TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><A name="z0209372">Examples</A></FONT></B></TD></TR></TABLE>

<BR><H3> <A name="z0177189">Example 1: Changing How Delimiters are Treated</A> </H3>


<P>By default, the INPUT statement uses a blank as the delimiter. This DATA step
uses a comma as the delimiter: 



<PRE>data num;
   infile datalines dsd;
   input x y z;
   datalines;
,2,3
4,5,6
7,8,9
;</PRE>


The argument DATALINES in the INFILE statement allows you to use an
INFILE statement option to read in-stream data lines. The DSD option sets
the comma as the default delimiter. Because a comma precedes the first value
in the first dataline, a missing value is assigned to variable X in the first
observation, and the value <B><CODE><FONT size="+1">2</FONT></CODE></B> is assigned to
variable Y.
<P>If the data uses multiple delimiters or a single delimiter
other than a comma, simply specify the delimiter values with the DELIMITER=
option. In this example, the characters a and b function as delimiters:  






<PRE> data nums;
    infile datalines dsd delimiter='ab';
    input X Y Z;
    datalines;
   1aa2ab3
   4b5bab6
   7a8b9
   ;</PRE>


The
output that PROC PRINT generates shows the resulting NUMS data set. Values
are missing for variables in the first and second observation because DSD
causes list input to detect two consecutive delimiters. If you omit DSD, the
characters a, b, aa, ab, ba, or bb function as the delimiter and no variables
are assigned missing values.
<P>
<P>
<B><I>The NUMS Data Set</I></B><BR>





<TABLE border="1" cellpadding="12" cellspacing="0" bgcolor="#FAFAFA">
<TR>
<TD><PRE>                         The SAS System                        1

                       OBS    X    Y    Z

                        1     1    .    2
                        2     4    5    .
                        3     7    8    9</PRE></TD></TR></TABLE>

<P>
<P>This DATA step uses modified list input and the DSD
option to read data that are separated by commas and that may contain commas
as part of a character value:






<PRE>data scores;
   infile datalines dsd;
   input Name : $9. Score
         Team  : $25. Div $;
   datalines;
Joseph,76,"Red Racers, Washington",AAA
Mitchel,82,"Blue Bunnies, Richmond",AAA
Sue Ellen,74,"Green Gazelles, Atlanta",AA
;</PRE>


The
output that PROC PRINT generates shows the resulting SCORES data set. The
delimiter (comma) is stored as part of the value of TEAM while the quotation
marks are not.    
The folowing output shows how to use the  tilde (~) format modifier in an
INPUT statement to retain the quotation marks in character data.
<P>
<P>
<B><I>Data Set SCORES</I></B><BR>





<TABLE border="1" cellpadding="12" cellspacing="0" bgcolor="#FAFAFA">
<TR>
<TD><PRE>                         The SAS System                        1

  OBS    NAME         SCORE             TEAM              DIV

   1     Joseph         76     Red Racers, Washington     AAA
   2     Mitchel        82     Blue Bunnies, Richmond     AAA
   3     Sue Ellen      74     Green Gazelles, Atlanta    AA </PRE></TD></TR></TABLE>

<P>
<BR><H3> <A name="z0177228">Example 2: Handling Missing Values and Short Records with List Input</A> </H3>


<P><A name="z0853761">&#13;This example demonstrates how to prevent missing values from
causing problems when you read the data with list input. Some data lines in
this example contain fewer than 5 temperature values. Use the MISSOVER option
so that these values are set to missing.  


</A>
<PRE>data weather;
   infile datalines missover;
   input temp1-temp5;
   datalines;
97.9 98.1 98.3
98.6 99.2 99.1 98.5 97.5
96.2 97.3 98.3 97.6 96.5
;</PRE>


SAS reads the three values on the first data line as the values of
TEMP1, TEMP2, and TEMP3. The MISSOVER option causes SAS to set the values
of TEMP4 and TEMP5 to missing for the first observation because no values
for those variables are in the current input data record. 
<P>When you omit MISSOVER option or use FLOWOVER, SAS moves
the input pointer to line 2 and reads values for TEMP4 and TEMP5. The next
time the DATA step executes, SAS reads a new line which, in this case, is
line 3. This message appears in the SAS log:



<PRE>NOTE: SAS went to a new line when INPUT statement
      reached past the end of a line.</PRE>
<P>You can also use the STOPOVER option in the INFILE statement.
This causes the DATA step to halt execution when an INPUT statement does not
find enough values in a record of raw data:  



<PRE> infile datalines stopover;</PRE>


Because
SAS does not find a TEMP4 value in the first data record, it sets _ERROR_
to 1, stops building the data set, and prints data line 1.
<BR><H3> <A name="z0178012">Example 3: Reading Files That Contain Variable-Length Records</A> </H3>


<P><A name="z0853764">&#13;This example shows how to use LENGTH=, in combination with the
$VARYING. informat, to read a file that contains variable-length records:
 


</A>
<PRE>data a;
   infile <I>file-specification</I> length=linelen; 
   input firstvar 1-10 @;  /* assign LINELEN   */
   varlen=linelen-10;      /* Calculate VARLEN */
   input @11 secondvar $varying500. varlen;
run;</PRE>


The following occurs in this DATA step: 
<P>
<UL>

<LI>The INFILE statement creates the variable LINELEN
but does not assign it a value.<P>

<LI>When the first INPUT statement executes, SAS determines
the line length of the record and assigns that value to the variable LINELEN.
The single trailing @ holds the record in the input buffer for the next INPUT
statement.<P>

<LI>The assignment statement uses the two known lengths
(the length of FIRSTVAR and the length of the entire record) to determine
the length of VARLEN.<P>

<LI>The second INPUT statement uses the VARLEN value
with the informat $VARYING500. to read the variable SECONDVAR.<P>
</UL>

<P>See the informat
<A href="z0193602.htm">$VARYING<I>w</I>.</A>    
 for more information.
<BR><H3> <A name="z0177201">Example 4: Reading from Multiple Input Files</A> </H3>


<P><A name="z0853770">&#13;The
following DATA step reads from two input files during each iteration of the
DATA step. As SAS switches from one file to the next, each file remains open.
The input pointer remains in place to begin reading from that location the
next time an INPUT statement reads from that file.  


</A>
<PRE>data qtrtot(drop=jansale febsale marsale
                 aprsale maysale junsale);
     /* identify location of 1st file */
   infile <I>file-specification-1</I>;
     /* read values from 1st file     */
   input name $ jansale febsale marsale; 
   qtr1tot=sum(jansale,febsale,marsale);

     /* identify location of 2nd file */
   infile <I>file-specification-2</I>;
     /* read values from 2nd file     */
   input @7 aprsale maysale junsale;
   qtr2tot=sum(aprsale,maysale,junsale);
run;</PRE>


The DATA step terminates when SAS reaches an end-of-file on the
shortest input file.
<P>This DATA step uses FILEVAR= to read from a different
file during each iteration of the DATA step:  



<PRE>data allsales;
   length fileloc myinfile $ 300;
   input fileloc $ ; /* read instream data       */

  /* The INFILE statement closes the current file 
     and opens a new one if FILELOC changes value 
     when INFILE executes                        */
   infile <I>file-specification</I> filevar=fileloc 
          filename=myinfile end=done; 

  /* DONE set to 1 when last input record read  */
   do while(not done);
  /* Read all input records from the currently  */
  /* opened input file, write to ALLSALES       */
     input name $ jansale febsale marsale;
     output;
   end;
   put 'Finished reading ' myinfile=; 
   datalines;
<I>external-file-1</I>
<I>external-file-2</I>
<I>external-file-3</I>
;</PRE>


 The FILENAME= option assigns the name of the current input file to
the variable MYINFILE. The LENGTH statement ensures that the FILENAME= variable
and FILEVAR= variable have a length long enough to contain the value of the
filename. The PUT statement prints the physical name of the currently open
input file to the SAS log.      
<BR><H3> <A name="z0177247">Example 5: Updating an External File</A> </H3>


<P><A name="z0853772">&#13;This
example shows how to use the INFILE statement with the SHAREBUFFERS option
and the INPUT, FILE, and PUT statements to update an external file in place:


</A>
<PRE>data _null_;
     /* The INFILE and FILE statements     */
     /* must specify the same file.       */
   infile <I>file-specification-1</I> sharebuffers;
   file <I>file-specification-1</I>;
   input state $ 1-2 phone $ 5-16; 
     /* Replace area code for NC exchanges */
   if state= 'NC' and substr(phone,5,3)='333' then
     phone='910-'||substr(phone,5,8);
   put phone 5-16;
run;</PRE>
<BR><H3> <A name="z0177221">Example 6: Truncating Copied Records</A> </H3>


<P><A name="z0853773">&#13;The
LENGTH= option is useful when you copy the input file to another file with
the PUT _INFILE_ statement. Use LENGTH= to truncate the copied records. For
example, these statements truncate  the last  20 columns from each input data
record before the input data record is written to the output file:  


</A>
<PRE>data _null_;
   infile  <I>file-specification-1</I> length=a;
   input;
   a=a-20;
   file <I>file-specification-2</I>;
   put _infile_;
run;</PRE>
<P>The START= option is also useful when you want to truncate
what the PUT _INFILE_ statement copies. For example, if you do not want to
copy the first 10 columns of each record, these statements copy from column
11 to the end of each record in the input buffer:  



<PRE>data _null_;
   infile <I>file-specification</I> start=s;
   input;
   s=11;
   file <I>file-specification-2</I>;
   put _infile_;
run;</PRE>
<BR><H3> <A name="z0177196">Example 7: Listing the Pointer Location</A> </H3>


<P><A name="z0853775">&#13;This DATA
step assigns the value of the current pointer location
in the input buffer to the variables LINEPT and COLUMNPT:  


</A>
<PRE>data _null_;
   infile datalines n=2 line=Linept col=Columnpt;
   input name $ 1-15 #2 @3 id;
   put linept= columnpt=;
   datalines;
J. Brooks
  40974
T. R. Ansen
  4032
;</PRE>


These statements produce the following line for each execution of
the DATA step because the input pointer is on the second line in the input
buffer when the PUT statement executes:  



<PRE>Linept=2 Columnpt=9
Linept=2 Columnpt=8</PRE>
<TABLE width="100%" cellpadding="0" cellspacing="0">
<TR valign="bottom"><TD><HR></TD></TR>
<TR valign="top"><TD><B><FONT size="5"><FONT size="5"><A name="z0209373">See Also</A></FONT>
</FONT></B></TD></TR></TABLE>
<P>
<TABLE cellpadding="6" cellspacing="2">
<TR valign="top"><TD></TD><TD>Statements:
<P>
<TABLE cellpadding="6" cellspacing="2">
<TR valign="top"><TD></TD><TD><A href="z0211297.htm">FILENAME</A></TD></TR>
<TR valign="top"><TD></TD><TD><A href="z0146292.htm">INPUT</A></TD></TR>
<TR valign="top"><TD></TD><TD><A href="z0161869.htm">PUT</A></TD></TR></TABLE></TD></TR></TABLE>

<P><!-- navigation -->
<P><TABLE cellpadding="0" cellspacing="0">
<TR valign="top">
<TD align="center">
<A href="z0293668.htm">
<IMG border="0" SRC="../common/images/cont1.gif"><BR><FONT size="-2">Chapter Contents</FONT></A></TD>
<TD align="center">
<A href="z0214504.htm">
<IMG border="0" src="../common/images/prev1.gif"><BR><FONT size="-2">Previous</FONT></A></TD>
<TD align="center">
<A href="z0178244.htm">
<IMG border="0" SRC="../common/images/next1.gif"><BR><FONT size="-2">Next</FONT></A></TD>
<TD align="center">
<A href="#z0146932">
<IMG border="0" SRC="../common/images/top1.gif"><BR><FONT size="-2">Top of Page</FONT></A></TD>
</TR></TABLE>
<P><FONT size=1><A href="../common/images/copyrite.htm">Copyright 1999 by SAS Institute Inc., Cary, NC, USA. All rights reserved.</A></FONT>
</BODY>
</HTML>
